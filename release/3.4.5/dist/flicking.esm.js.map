{"version":3,"file":"flicking.esm.js","sources":["../src/consts.ts","../src/utils.ts","../src/components/Panel.ts","../src/components/PanelManager.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/moves/MoveType.ts","../src/moves/Snap.ts","../src/moves/FreeScroll.ts","../src/components/Viewport.ts","../src/ga/ga.ts","../src/Flicking.ts","../src/types.ts"],"sourcesContent":["/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { FlickingOptions, EventType, Direction, AxesEventType, StateType, MoveTypeSnapOption, MoveTypeFreeScrollOption, FlickingMethodsKeys } from \"./types\";\n\nexport const MOVE_TYPE: {\n  SNAP: \"snap\";\n  FREE_SCROLL: \"freeScroll\";\n} = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n};\n\nexport const DEFAULT_MOVE_TYPE_OPTIONS: {\n  snap: MoveTypeSnapOption,\n  freeScroll: MoveTypeFreeScrollOption,\n} = {\n  snap: {\n    type: \"snap\",\n    count: 1,\n  },\n  freeScroll: {\n    type: \"freeScroll\",\n  },\n};\nexport const isBrowser = typeof document !== \"undefined\";\n\n/**\n * Default options for creating Flicking.\n * @ko 플리킹을 만들 때 사용하는 기본 옵션들\n * @private\n * @memberof eg.Flicking\n */\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  infinite: false,\n  infiniteThreshold: 0,\n  lastIndex: Infinity,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  moveType: DEFAULT_MOVE_TYPE_OPTIONS.snap,\n  useOffset: false,\n  isEqualSize: false,\n  isConstantSize: false,\n  renderOnlyVisible: false,\n  renderExternal: false,\n  collectStatistics: true,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\nexport const FLICKING_METHODS: {[key in FlickingMethodsKeys]: true} = {\n  prev: true,\n  next: true,\n  moveTo: true,\n  getIndex: true,\n  getAllPanels: true,\n  getCurrentPanel: true,\n  getElement: true,\n  getPanel: true,\n  getPanelCount: true,\n  getStatus: true,\n  getVisiblePanels: true,\n  enableInput: true,\n  disableInput: true,\n  destroy: true,\n  resize: true,\n  setStatus: true,\n  isPlaying: true,\n};\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  if (!isBrowser) {\n    return {\n      name: transforms.transform,\n      has3d: true,\n    };\n  }\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { ElementLike, OriginalStyle, BoundingBox } from \"./types\";\nimport Flicking from \"./Flicking\";\nimport { FLICKING_METHODS } from \"./consts\";\n\nexport function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\nexport function parseElement(element: ElementLike | ElementLike[]): HTMLElement[] {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else {\n      elements.push(el as HTMLElement);\n    }\n  });\n\n  return elements;\n}\n\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (!hasClass(element, className)) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function hasClass(element: HTMLElement, className: string): boolean {\n  if (element.classList) {\n    return element.classList.contains(className);\n  } else {\n    return (element.className.split(\" \").indexOf(className) >= 0);\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n\nexport function findIndex<T>(iterable: T[], callback: (el: T) => boolean): number {\n  for (let i = 0; i < iterable.length; i += 1) {\n    const element = iterable[i];\n    if (element && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n// return [0, 1, ...., max - 1]\nexport function counter(max: number): number[] {\n  const counterArray: number[] = [];\n  for (let i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n  return counterArray;\n}\n\n// Circulate number between range [min, max]\n/*\n * \"indexed\" means min and max is not same, so if it's true \"min - 1\" should be max\n * While if it's false, \"min - 1\" should be \"max - 1\"\n * use `indexed: true` when it should be used for circulating integers like index\n * or `indexed: false` when it should be used for something like positions.\n */\nexport function circulate(value: number, min: number, max: number, indexed: boolean): number {\n  const size = indexed\n    ? max - min + 1\n    : max - min;\n  if (value < min) {\n    const offset = indexed\n      ? (min - value - 1) % size\n      : (min - value) % size;\n    value = max - offset;\n  } else if (value > max) {\n    const offset = indexed\n      ? (value - max - 1) % size\n      : (value - max) % size;\n    value = min + offset;\n  }\n\n  return value;\n}\n\nexport function restoreStyle(element: HTMLElement, originalStyle: OriginalStyle): void {\n  originalStyle.className\n    ? element.setAttribute(\"class\", originalStyle.className)\n    : element.removeAttribute(\"class\");\n  originalStyle.style\n    ? element.setAttribute(\"style\", originalStyle.style)\n    : element.removeAttribute(\"style\");\n}\n\n/**\n * Decorator that makes the method of flicking available in the framework.\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Flicking\n * @private\n * @example\n * ```js\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\n *\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\n *   &#64;withFlickingMethods\n *   private flicking: Flicking;\n * }\n * ```\n */\nexport function withFlickingMethods(prototype: any, flickingName: string) {\n  Object.keys(FLICKING_METHODS).forEach((name: keyof Flicking) => {\n    if (prototype[name]) {\n      return;\n    }\n    prototype[name] = function(...args) {\n      const result = this[flickingName][name](...args);\n\n      // fix `this` type to return your own `flicking` instance to the instance using the decorator.\n      if (result === this[flickingName]) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n  });\n}\n\nexport function getBbox(element: HTMLElement, useOffset: boolean) {\n  let bbox: BoundingBox;\n  if (useOffset) {\n    bbox = {\n      x: 0,\n      y: 0,\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n    };\n  } else {\n    const clientRect = element.getBoundingClientRect();\n    bbox = {\n      x: clientRect.left,\n      y: clientRect.top,\n      width: clientRect.width,\n      height: clientRect.height,\n    };\n  }\n  return bbox;\n}\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Viewport from \"./Viewport\";\nimport { OriginalStyle, FlickingPanel, ElementLike, DestroyOption, BoundingBox } from \"../types\";\nimport { DEFAULT_PANEL_CSS, EVENTS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression, parseElement, getProgress, restoreStyle, hasClass, getBbox } from \"../utils\";\n\nclass Panel implements FlickingPanel {\n  public viewport: Viewport;\n  public prevSibling: Panel | null;\n  public nextSibling: Panel | null;\n\n  protected state: {\n    index: number;\n    position: number;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    isVirtual: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    cachedBbox: BoundingBox | null;\n  };\n  private element: HTMLElement;\n  private original?: Panel;\n  private clonedPanels: Panel[];\n\n  public constructor(\n    element?: HTMLElement | null,\n    index?: number,\n    viewport?: Viewport,\n  ) {\n    this.viewport = viewport!;\n    this.prevSibling = null;\n    this.nextSibling = null;\n    this.clonedPanels = [];\n\n    this.state = {\n      index: index!,\n      position: 0,\n      relativeAnchorPosition: 0,\n      size: 0,\n      isClone: false,\n      isVirtual: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: \"\",\n        style: \"\",\n      },\n      cachedBbox: null,\n    };\n    this.setElement(element);\n  }\n\n  public resize(givenBbox?: BoundingBox): void {\n    const state = this.state;\n    const options = this.viewport.options;\n    const bbox = givenBbox\n      ? givenBbox\n      : this.getBbox();\n    this.state.cachedBbox = bbox;\n    const prevSize = state.size;\n\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    if (prevSize !== state.size) {\n      state.relativeAnchorPosition = parseArithmeticExpression(options.anchor, state.size);\n    }\n\n    if (!state.isClone) {\n      this.clonedPanels.forEach(panel => {\n        const cloneState = panel.state;\n\n        cloneState.size = state.size;\n        cloneState.cachedBbox = state.cachedBbox;\n        cloneState.relativeAnchorPosition = state.relativeAnchorPosition;\n      });\n    }\n  }\n\n  public unCacheBbox(): void {\n    this.state.cachedBbox = null;\n  }\n\n  public getProgress() {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const panelCount = viewport.panelManager.getPanelCount();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n\n    const relativeIndex = (options.circular ? Math.floor(this.getPosition() / scrollAreaSize) * panelCount : 0) + this.getIndex();\n    const progress = relativeIndex - viewport.getCurrentProgress();\n\n    return progress;\n  }\n\n  public getOutsetProgress() {\n    const viewport = this.viewport;\n    const outsetRange = [\n      -this.getSize(),\n      viewport.getRelativeHangerPosition() - this.getRelativeAnchorPosition(),\n      viewport.getSize(),\n    ];\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const outsetProgress = getProgress(relativePanelPosition, outsetRange);\n\n    return outsetProgress;\n  }\n\n  public getVisibleRatio() {\n    const viewport = this.viewport;\n    const panelSize = this.getSize();\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const rightRelativePanelPosition = relativePanelPosition + panelSize;\n\n    const visibleSize = Math.min(viewport.getSize(), rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n    const visibleRatio = visibleSize >= 0\n      ? visibleSize / panelSize\n      : 0;\n\n    return visibleRatio;\n  }\n\n  public focus(duration?: number): void {\n    const viewport = this.viewport;\n    const currentPanel = viewport.getCurrentPanel();\n    const hangerPosition = viewport.getHangerPosition();\n    const anchorPosition = this.getAnchorPosition();\n    if (hangerPosition === anchorPosition || !currentPanel) {\n      return;\n    }\n\n    const currentPosition = currentPanel.getPosition();\n    const eventType = currentPosition === this.getPosition()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(this, viewport.findEstimatedPosition(this), eventType, null, duration);\n  }\n\n  public update(updateFunction: ((element: HTMLElement) => any) | null = null, shouldResize: boolean = true): void {\n    const identicalPanels = this.getIdenticalPanels();\n\n    if (updateFunction) {\n      identicalPanels.forEach(eachPanel => {\n        updateFunction(eachPanel.getElement());\n      });\n    }\n\n    if (shouldResize) {\n      identicalPanels.forEach(eachPanel => {\n        eachPanel.unCacheBbox();\n      });\n      this.viewport.addVisiblePanel(this);\n      this.viewport.resize();\n    }\n  }\n\n  public prev(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const prevSibling = this.prevSibling;\n\n    if (!prevSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const prevPanelIndex = prevSibling.getIndex();\n    const prevPanelPosition = prevSibling.getPosition();\n    const prevPanelSize = prevSibling.getSize();\n\n    const hasEmptyPanelBetween = currentIndex - prevPanelIndex > 1;\n    const notYetMinPanel = options.infinite\n      && currentIndex > 0\n      && prevPanelIndex > currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMinPanel) {\n      // Empty panel exists between\n      return null;\n    }\n\n    const newPosition = currentPosition - prevPanelSize - options.gap;\n\n    let prevPanel = prevSibling;\n    if (prevPanelPosition !== newPosition) {\n      prevPanel = prevSibling.clone(prevSibling.getCloneIndex(), true);\n      prevPanel.setPosition(newPosition);\n    }\n\n    return prevPanel;\n  }\n\n  public next(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const nextSibling = this.nextSibling;\n    const lastIndex = viewport.panelManager.getLastIndex();\n\n    if (!nextSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const nextPanelIndex = nextSibling.getIndex();\n    const nextPanelPosition = nextSibling.getPosition();\n\n    const hasEmptyPanelBetween = nextPanelIndex - currentIndex > 1;\n    const notYetMaxPanel = options.infinite\n      && currentIndex < lastIndex\n      && nextPanelIndex < currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMaxPanel) {\n      return null;\n    }\n\n    const newPosition = currentPosition + this.getSize() + options.gap;\n\n    let nextPanel = nextSibling;\n    if (nextPanelPosition !== newPosition) {\n      nextPanel = nextSibling.clone(nextSibling.getCloneIndex(), true);\n      nextPanel.setPosition(newPosition);\n    }\n\n    return nextPanel;\n  }\n\n  public insertBefore(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n    const firstPanel = viewport.panelManager.firstPanel()!;\n    const prevSibling = this.prevSibling;\n    // Finding correct inserting index\n    // While it should insert removing empty spaces,\n    // It also should have to be bigger than prevSibling' s index\n    const targetIndex = prevSibling && firstPanel.getIndex() !== this.getIndex()\n      ? Math.max(prevSibling.getIndex() + 1, this.getIndex() - parsedElements.length)\n      : Math.max(this.getIndex() - parsedElements.length, 0);\n\n    return viewport.insert(targetIndex, parsedElements);\n  }\n\n  public insertAfter(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.insert(this.getIndex() + 1, element);\n  }\n\n  public remove(): FlickingPanel {\n    this.viewport.remove(this.getIndex());\n\n    return this;\n  }\n\n  public destroy(option: Partial<DestroyOption>): void {\n    if (!option.preserveUI) {\n      const originalStyle = this.state.originalStyle;\n\n      restoreStyle(this.element, originalStyle);\n    }\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getBbox(): BoundingBox {\n    const state = this.state;\n    const viewport = this.viewport;\n    const element = this.element;\n    const options = viewport.options;\n\n    if (!element) {\n      state.cachedBbox = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n      };\n    } else if (!state.cachedBbox) {\n      const wasVisible = Boolean(element.parentNode);\n      const cameraElement = viewport.getCameraElement();\n      if (!wasVisible) {\n        cameraElement.appendChild(element);\n        viewport.addVisiblePanel(this);\n      }\n      state.cachedBbox = getBbox(element, options.useOffset);\n\n      if (!wasVisible && viewport.options.renderExternal) {\n        cameraElement.removeChild(element);\n      }\n    }\n    return state.cachedBbox!;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getOverlappedClass(classes: string[]): string | undefined {\n    const element = this.element;\n\n    for (const className of classes) {\n      if (hasClass(element, className)) {\n        return className;\n      }\n    }\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getClonedPanels()\n      : this.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...this.clonedPanels];\n  }\n\n  public getOriginalPanel(): Panel {\n    return this.state.isClone\n      ? this.original!\n      : this;\n  }\n\n  public setIndex(index: number): void {\n    const state = this.state;\n\n    state.index = index;\n    this.clonedPanels.forEach(panel => panel.state.index = index);\n  }\n\n  public setPosition(pos: number): this {\n    this.state.position = pos;\n\n    return this;\n  }\n\n  public setPositionCSS(offset: number = 0): void {\n    if (!this.element) {\n      return;\n    }\n    const state = this.state;\n    const pos = state.position;\n    const options = this.viewport.options;\n    const elementStyle = this.element.style;\n    const currentElementStyle = options.horizontal\n      ? elementStyle.left\n      : elementStyle.top;\n    const styleToApply = `${pos - offset}px`;\n\n    if (!state.isVirtual && currentElementStyle !== styleToApply) {\n      options.horizontal\n        ? elementStyle.left = styleToApply\n        : elementStyle.top = styleToApply;\n    }\n  }\n\n  public clone(cloneIndex: number, isVirtual: boolean = false, element?: HTMLElement | null): Panel {\n    const state = this.state;\n    const viewport = this.viewport;\n    let cloneElement = element;\n\n    if (!cloneElement && this.element) {\n      cloneElement = isVirtual ? this.element : this.element.cloneNode(true) as HTMLElement;\n    }\n    const clonedPanel = new Panel(cloneElement, state.index, viewport);\n    const clonedState = clonedPanel.state;\n\n    clonedPanel.original = state.isClone\n      ? this.original\n      : this;\n    clonedState.isClone = true;\n    clonedState.isVirtual = isVirtual;\n    clonedState.cloneIndex = cloneIndex;\n    // Inherit some state values\n    clonedState.size = state.size;\n    clonedState.relativeAnchorPosition = state.relativeAnchorPosition;\n    clonedState.originalStyle = state.originalStyle;\n    clonedState.cachedBbox = state.cachedBbox;\n\n    if (!isVirtual) {\n      this.clonedPanels.push(clonedPanel);\n    } else {\n      clonedPanel.prevSibling = this.prevSibling;\n      clonedPanel.nextSibling = this.nextSibling;\n    }\n\n    return clonedPanel;\n  }\n\n  public removeElement(): void {\n    if (!this.viewport.options.renderExternal) {\n      const element = this.element;\n      element.parentNode!.removeChild(element);\n    }\n\n    // Do the same thing for clones\n    if (!this.state.isClone) {\n      this.removeClonedPanelsAfter(0);\n    }\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const options = this.viewport.options;\n    const removingPanels = this.clonedPanels.splice(start);\n\n    if (!options.renderExternal && !options.renderOnlyVisible) {\n      removingPanels.forEach(panel => {\n        panel.removeElement();\n      });\n    }\n  }\n\n  public setElement(element?: HTMLElement | null): void {\n    if (!element) {\n      return;\n    }\n    const currentElement = this.element;\n    if (element !== currentElement) {\n      const options = this.viewport.options;\n\n      if (currentElement) {\n        if (options.horizontal) {\n          element.style.left = currentElement.style.left;\n        } else {\n          element.style.top = currentElement.style.top;\n        }\n      } else {\n        const originalStyle = this.state.originalStyle;\n\n        originalStyle.className = element.getAttribute(\"class\");\n        originalStyle.style = element.getAttribute(\"style\");\n      }\n\n      this.element = element;\n\n      if (options.classPrefix) {\n        addClass(element, `${options.classPrefix}-panel`);\n      }\n\n      // Update size info after applying panel css\n      applyCSS(this.element, DEFAULT_PANEL_CSS);\n    }\n  }\n}\n\nexport default Panel;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Panel from \"./Panel\";\nimport { FlickingOptions } from \"../types\";\nimport { findIndex, counter } from \"../utils\";\n\nclass PanelManager {\n  private cameraElement: HTMLElement;\n  private options: FlickingOptions;\n  private panels: Panel[];\n  private clones: Panel[][];\n  // index range of existing panels\n  private range: {\n    min: number;\n    max: number;\n  };\n  private length: number;\n  private lastIndex: number;\n  private cloneCount: number;\n\n  constructor(\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.cameraElement = cameraElement;\n    this.panels = [];\n    this.clones = [];\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n    this.length = 0;\n    this.cloneCount = 0;\n    this.options = options;\n    this.lastIndex = options.lastIndex;\n  }\n\n  public firstPanel(): Panel | undefined {\n    return this.panels[this.range.min];\n  }\n\n  public lastPanel(): Panel | undefined {\n    return this.panels[this.range.max];\n  }\n\n  public allPanels(): ReadonlyArray<Panel> {\n    return [\n      ...this.panels,\n      ...this.clones.reduce((allClones, clones) => [...allClones, ...clones], []),\n    ];\n  }\n\n  public originalPanels(): ReadonlyArray<Panel> {\n    return this.panels;\n  }\n\n  public clonedPanels(): ReadonlyArray<Panel[]> {\n    return this.clones;\n  }\n\n  public replacePanels(newPanels: Panel[], newClones: Panel[][]): void {\n    this.panels = newPanels;\n    this.clones = newClones;\n\n    this.range = {\n      min: findIndex(newPanels, panel => Boolean(panel)),\n      max: newPanels.length - 1,\n    };\n    this.length = newPanels.filter(panel => Boolean(panel)).length;\n  }\n\n  public has(index: number): boolean {\n    return !!this.panels[index];\n  }\n\n  public get(index: number): Panel | undefined {\n    return this.panels[index];\n  }\n\n  public getPanelCount(): number {\n    return this.length;\n  }\n\n  public getLastIndex(): number {\n    return this.lastIndex;\n  }\n\n  public getRange(): Readonly<{ min: number, max: number }> {\n    return this.range;\n  }\n\n  public getCloneCount(): number {\n    return this.cloneCount;\n  }\n\n  public setLastIndex(lastIndex: number): void {\n    this.lastIndex = lastIndex;\n\n    const firstPanel = this.firstPanel();\n    const lastPanel = this.lastPanel();\n\n    if (!firstPanel || !lastPanel) {\n      return; // no meaning of updating range & length\n    }\n\n    // Remove panels above new last index\n    const range = this.range;\n    if (lastPanel.getIndex() > lastIndex) {\n      const removingPanels = this.panels.splice(lastIndex + 1);\n      this.length -= removingPanels.length;\n\n      const firstRemovedPanel = removingPanels.filter(panel => !!panel)[0];\n      const possibleLastPanel = firstRemovedPanel.prevSibling;\n      if (possibleLastPanel) {\n        range.max = possibleLastPanel.getIndex();\n      } else {\n        range.min = -1;\n        range.max = -1;\n      }\n\n      if (this.shouldRender()) {\n        removingPanels.forEach(panel => panel.removeElement());\n      }\n    }\n  }\n\n  public setCloneCount(cloneCount: number): void {\n    this.cloneCount = cloneCount;\n  }\n\n  // Insert at index\n  // Returns pushed elements from index, inserting at 'empty' position doesn't push elements behind it\n  public insert(index: number, newPanels: Panel[]): number {\n    const panels = this.panels;\n    const range = this.range;\n    const isCircular = this.options.circular;\n    const lastIndex = this.lastIndex;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    this.insertNewPanels(newPanels, siblingElement);\n\n    let pushedIndex = newPanels.length;\n    // Like when setting index 50 while visible panels are 0, 1, 2\n    if (index > range.max) {\n      newPanels.forEach((panel, offset) => {\n        panels[index + offset] = panel;\n      });\n    } else {\n      const panelsAfterIndex = panels.slice(index, index + newPanels.length);\n      // Find empty from beginning\n      let emptyPanelCount = findIndex(panelsAfterIndex, panel => !!panel);\n      if (emptyPanelCount < 0) {\n        // All empty\n        emptyPanelCount = panelsAfterIndex.length;\n      }\n      pushedIndex = newPanels.length - emptyPanelCount;\n\n      // Insert removing empty panels\n      panels.splice(index, emptyPanelCount, ...newPanels);\n\n      // Remove panels after last index\n      if (panels.length > lastIndex + 1) {\n        const removedPanels = panels.splice(lastIndex + 1)\n          .filter(panel => Boolean(panel));\n        this.length -= removedPanels.length;\n\n        // Find first\n        const newLastIndex = lastIndex - findIndex(this.panels.concat().reverse(), panel => !!panel);\n\n        // Can be filled with empty after newLastIndex\n        this.panels.splice(newLastIndex + 1);\n        this.range.max = newLastIndex;\n\n        if (this.shouldRender()) {\n          removedPanels.forEach(panel => panel.removeElement());\n        }\n      }\n    }\n\n    // Update index of previous panels\n    if (pushedIndex > 0) {\n      panels.slice(index + newPanels.length).forEach(panel => {\n        panel.setIndex(panel.getIndex() + pushedIndex);\n      });\n    }\n\n    // Update state\n    this.length += newPanels.length;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length - pushedIndex, nextSibling);\n      const clones = this.clones;\n      const panelCount = this.panels.length;\n      if (clones[0] && clones[0].length > lastIndex + 1) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(panelCount);\n        });\n      }\n    }\n\n    return pushedIndex;\n  }\n\n  public replace(index: number, newPanels: Panel[]): Panel[] {\n    const panels = this.panels;\n    const range = this.range;\n    const options = this.options;\n    const isCircular = options.circular;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index + newPanels.length);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    this.insertNewPanels(newPanels, siblingElement);\n\n    if (index > range.max) {\n      // Temporarily insert null at index to use splice()\n      (panels[index] as any) = null;\n    }\n\n    const replacedPanels = panels.splice(index, newPanels.length, ...newPanels);\n    const wasNonEmptyCount = replacedPanels.filter(panel => Boolean(panel)).length;\n\n    // Suppose inserting [1, 2, 3] at 0 position when there were [empty, 1]\n    // So length should be increased by 3(inserting panels) - 1(non-empty panels)\n    this.length += newPanels.length - wasNonEmptyCount;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length, nextSibling);\n    }\n\n    if (this.shouldRender()) {\n      replacedPanels.forEach(panel => panel && panel.removeElement());\n    }\n\n    return replacedPanels;\n  }\n\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    const isCircular = this.options.circular;\n    const panels = this.panels;\n    const clones = this.clones;\n    // Delete count should be equal or larger than 0\n    deleteCount = Math.max(deleteCount, 0);\n\n    const deletedPanels = panels\n      .splice(index, deleteCount)\n      .filter(panel => !!panel);\n\n    if (this.shouldRender()) {\n      deletedPanels.forEach(panel => panel.removeElement());\n    }\n\n    if (isCircular) {\n      clones.forEach(cloneSet => {\n        cloneSet.splice(index, deleteCount);\n      });\n    }\n\n    // Update indexes\n    panels\n      .slice(index)\n      .forEach(panel => {\n        panel.setIndex(panel.getIndex() - deleteCount);\n      });\n\n    // Check last panel is empty\n    let lastIndex = panels.length - 1;\n    if (!panels[lastIndex]) {\n      const reversedPanels = panels.concat().reverse();\n      const nonEmptyIndexFromLast = findIndex(reversedPanels, panel => !!panel);\n      lastIndex = nonEmptyIndexFromLast < 0\n        ? -1 // All empty\n        : lastIndex - nonEmptyIndexFromLast;\n\n      // Remove all empty panels from last\n      panels.splice(lastIndex + 1);\n      if (isCircular) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(lastIndex + 1);\n        });\n      }\n    }\n\n    // Update range & length\n    this.range = {\n      min: findIndex(panels, panel => !!panel),\n      max: lastIndex,\n    };\n    this.length -= deletedPanels.length;\n\n    if (this.length <= 0) {\n      // Reset clones\n      this.clones = [];\n      this.cloneCount = 0;\n    }\n\n    return deletedPanels;\n  }\n\n  public chainAllPanels() {\n    const allPanels = this.allPanels().filter(panel => !!panel);\n    const allPanelsCount = allPanels.length;\n\n    if (allPanelsCount <= 1) {\n      return;\n    }\n\n    allPanels.slice(1, allPanels.length - 1).forEach((panel, idx) => {\n      const prevPanel = allPanels[idx];\n      const nextPanel = allPanels[idx + 2];\n\n      panel.prevSibling = prevPanel;\n      panel.nextSibling = nextPanel;\n    });\n\n    const firstPanel = allPanels[0];\n    const lastPanel = allPanels[allPanelsCount - 1];\n\n    firstPanel.prevSibling = null;\n    firstPanel.nextSibling = allPanels[1];\n    lastPanel.prevSibling = allPanels[allPanelsCount - 2];\n    lastPanel.nextSibling = null;\n\n    if (this.options.circular) {\n      firstPanel.prevSibling = lastPanel;\n      lastPanel.nextSibling = firstPanel;\n    }\n  }\n\n  public insertClones(cloneIndex: number, index: number, clonedPanels: Panel[], deleteCount: number = 0): void {\n    const clones = this.clones;\n    const lastIndex = this.lastIndex;\n\n    if (!clones[cloneIndex]) {\n      const newClones: Panel[] = [];\n      clonedPanels.forEach((panel, offset) => {\n        newClones[index + offset] = panel;\n      });\n\n      clones[cloneIndex] = newClones;\n    } else {\n      const insertTarget = clones[cloneIndex];\n\n      if (index >= insertTarget.length) {\n        clonedPanels.forEach((panel, offset) => {\n          insertTarget[index + offset] = panel;\n        });\n      } else {\n        insertTarget.splice(index, deleteCount, ...clonedPanels);\n        // Remove panels after last index\n        if (clonedPanels.length > lastIndex + 1) {\n          clonedPanels.splice(lastIndex + 1);\n        }\n      }\n    }\n  }\n\n  // clones are operating in set\n  public removeClonesAfter(cloneIndex: number): void {\n    const panels = this.panels;\n\n    panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(cloneIndex);\n    });\n    this.clones.splice(cloneIndex);\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    const allPanels = this.allPanels();\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findFirstPanelFrom(index: number): Panel | undefined {\n    for (const panel of this.panels.slice(index)) {\n      if (panel && panel.getIndex() >= index && panel.getElement().parentNode) {\n        return panel;\n      }\n    }\n  }\n\n  private addNewClones(index: number, originalPanels: Panel[], deleteCount: number, nextSibling: Panel | undefined) {\n    const cameraElement = this.cameraElement;\n    const cloneCount = this.getCloneCount();\n    const lastPanel = this.lastPanel();\n    const lastPanelClones: Panel[] = lastPanel\n      ? lastPanel.getClonedPanels()\n      : [];\n    const nextSiblingClones: Panel[] = nextSibling\n      ? nextSibling.getClonedPanels()\n      : [];\n\n    for (const cloneIndex of counter(cloneCount)) {\n      const cloneNextSibling = nextSiblingClones[cloneIndex];\n      const lastPanelSibling = lastPanelClones[cloneIndex];\n\n      const cloneSiblingElement = cloneNextSibling\n        ? cloneNextSibling.getElement()\n        : lastPanelSibling\n          ? lastPanelSibling.getElement().nextElementSibling\n          : null;\n\n      const newClones = originalPanels.map(panel => {\n        const clone = panel.clone(cloneIndex);\n\n        if (this.shouldRender()) {\n          cameraElement.insertBefore(clone.getElement(), cloneSiblingElement);\n        }\n\n        return clone;\n      });\n\n      this.insertClones(cloneIndex, index, newClones, deleteCount);\n    }\n  }\n\n  private updateIndex(insertingIndex: number) {\n    const panels = this.panels;\n    const range = this.range;\n\n    const newLastIndex = panels.length - 1;\n    if (newLastIndex > range.max) {\n      range.max = newLastIndex;\n    }\n    if (insertingIndex < range.min || range.min < 0) {\n      range.min = insertingIndex;\n    }\n  }\n\n  private insertNewPanels(newPanels: Panel[], siblingElement: HTMLElement | null) {\n    if (this.shouldRender()) {\n      const fragment = document.createDocumentFragment();\n      newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n      this.cameraElement.insertBefore(fragment, siblingElement);\n    }\n  }\n\n  private shouldRender(): boolean {\n    const options = this.options;\n\n    return !options.renderExternal && !options.renderOnlyVisible;\n  }\n}\n\nexport default PanelManager;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Panel from \"../components/Panel\";\nimport { ValueOf, Direction, StateType, FlickingContext } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: Panel | null = null;\n  public lastPosition: number = 0;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n    this.lastPosition = prevState.lastPosition;\n  }\n\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n\n  public onHold(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n\n  public onChange(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n\n  public onAnimationEnd(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n\n  public onFinish(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n    this.lastPosition = 0;\n  }\n\n  public onHold(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Shouldn't do any action until any panels on flicking area\n    if (flicking.getPanelCount() <= 0) {\n      if (viewport.options.infinite) {\n        viewport.moveCamera(viewport.getCameraPosition(), e);\n      }\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    this.lastPosition = viewport.getCameraPosition();\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: any, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: any, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const srcEvent = releaseEvent.inputEvent.srcEvent;\n\n    let clickedElement: HTMLElement;\n    if (srcEvent.type === \"touchend\") {\n      const touchEvent = srcEvent as TouchEvent;\n      const touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY) as HTMLElement;\n    } else {\n      clickedElement = srcEvent.target;\n    }\n    const clickedPanel = viewport.panelManager.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction, // Direction to the clicked panel\n        index: clickedPanel.getIndex(),\n        panel: clickedPanel,\n      });\n    }\n  }\n}\n\nexport default HoldingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, transitTo, stopCamera } = context;\n\n    const delta = this.delta;\n    const absDelta = Math.abs(delta);\n    const options = flicking.options;\n    const horizontal = options.horizontal;\n    const moveType = viewport.moveType;\n    const inputEvent = e.inputEvent;\n\n    const velocity = horizontal\n      ? inputEvent.velocityX\n      : inputEvent.velocityY;\n    const inputDelta = horizontal\n      ? inputEvent.deltaX\n      : inputEvent.deltaY;\n    const isNextDirection = Math.abs(velocity) > 1\n      ? velocity < 0\n      : absDelta > 0\n        ? delta > 0\n        : inputDelta < 0;\n\n    const swipeDistance = viewport.options.bound\n      ? Math.max(absDelta, Math.abs(inputDelta))\n      : absDelta;\n    const swipeAngle = inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(inputEvent.deltaY / inputEvent.deltaX) / Math.PI)\n      : 90;\n    const belowAngleThreshold = horizontal\n      ? swipeAngle <= options.thresholdAngle\n      : swipeAngle > options.thresholdAngle;\n    const overThreshold = swipeDistance >= options.threshold\n      && belowAngleThreshold;\n\n    const moveTypeContext = {\n      viewport,\n      axesEvent: e,\n      state: this,\n      swipeDistance,\n      isNextDirection,\n    };\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    const targetPanel = this.targetPanel;\n    if (!overThreshold && targetPanel) {\n      // Interrupted while animating\n      const interruptDestInfo = moveType.findPanelWhenInterrupted(moveTypeContext);\n\n      viewport.moveTo(\n        interruptDestInfo.panel,\n        interruptDestInfo.destPos,\n        interruptDestInfo.eventType,\n        e,\n        interruptDestInfo.duration,\n      );\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const nearestPanel = viewport.getNearestPanel();\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      e.stop();\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    const destInfo = overThreshold\n      ? moveType.findTargetPanel(moveTypeContext)\n      : moveType.findRestorePanel(moveTypeContext);\n\n    viewport.moveTo(\n      destInfo.panel,\n      destInfo.destPos,\n      destInfo.eventType,\n      e,\n      destInfo.duration,\n    ).onSuccess(() => {\n      transitTo(STATE_TYPE.ANIMATING);\n    }).onStopped(() => {\n      transitTo(STATE_TYPE.DISABLED);\n      stopCamera(e);\n    });\n  }\n}\n\nexport default DraggingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\nimport { circulate } from \"../utils\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    const options = viewport.options;\n    const scrollArea = viewport.getScrollArea();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const loopCount = Math.floor((this.lastPosition + this.delta - scrollArea.prev) / scrollAreaSize);\n\n    const targetPanel = this.targetPanel;\n    if (options.circular && loopCount !== 0 && targetPanel) {\n      const cloneCount = viewport.panelManager.getCloneCount();\n      const originalTargetPosition = targetPanel.getPosition();\n\n      // cloneIndex is from -1 to cloneCount - 1\n      const newCloneIndex = circulate(targetPanel.getCloneIndex() - loopCount, -1, cloneCount - 1, true);\n      const newTargetPosition = originalTargetPosition - loopCount * scrollAreaSize;\n      const newTargetPanel = targetPanel.getIdenticalPanels()[newCloneIndex + 1].clone(newCloneIndex, true);\n\n      // Set new target panel considering looped count\n      newTargetPanel.setPosition(newTargetPosition);\n      this.targetPanel = newTargetPanel;\n    }\n\n    // Reset last position and delta\n    this.delta = 0;\n    this.lastPosition = viewport.getCameraPosition();\n\n    // Update current panel as current nearest panel\n    viewport.setCurrentPanel(viewport.getNearestPanel()!);\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n\n    viewport.options.bound\n      ? viewport.setCurrentPanel(this.targetPanel!)\n      : viewport.setCurrentPanel(viewport.getNearestPanel()!);\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n\n    transitTo(STATE_TYPE.IDLE);\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted, {\n      direction: this.direction,\n    });\n  }\n}\n\nexport default AnimatingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: any, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(e: any, { viewport, transitTo }: FlickingContext): void {\n    // Can stop Axes's change event\n    e.stop();\n\n    // Should update axes position as it's already changed at this moment\n    viewport.updateAxesPosition(viewport.getCameraPosition());\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: any, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { MoveTypeStringOption, MoveTypeContext, DestinationInfo } from \"../types\";\nimport Panel from \"../components/Panel\";\nimport { EVENTS } from \"../consts\";\n\nabstract class MoveType {\n  protected readonly abstract type: string;\n\n  public abstract findTargetPanel(ctx: MoveTypeContext): DestinationInfo;\n\n  public is(type: MoveTypeStringOption): boolean {\n    return type === this.type;\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    const viewport = ctx.viewport;\n    const options = viewport.options;\n\n    const panel = options.circular\n      ? this.findRestorePanelInCircularMode(ctx)\n      : viewport.getCurrentPanel()!;\n\n    return {\n      panel,\n      destPos: viewport.findEstimatedPosition(panel),\n      duration: options.duration,\n      eventType: EVENTS.RESTORE,\n    };\n  }\n\n  public findPanelWhenInterrupted(ctx: MoveTypeContext): DestinationInfo {\n    const { state, viewport } = ctx;\n    const targetPanel = state.targetPanel!;\n\n    return {\n      panel: targetPanel,\n      destPos: viewport.findEstimatedPosition(targetPanel),\n      duration: viewport.options.duration,\n      eventType: \"\",\n    };\n  }\n\n  // Calculate minimum distance to \"change\" panel\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const relativeAnchorPosition = currentPanel.getRelativeAnchorPosition();\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |--------|--------------|\n     * [][      |<-Anchor    ][] <- Panel + Half-Gap\n     */\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanel.getSize() - relativeAnchorPosition + halfGap\n      : relativeAnchorPosition + halfGap;\n\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    return minimumDistanceToChange;\n  }\n\n  private findRestorePanelInCircularMode(ctx: MoveTypeContext): Panel {\n    const viewport = ctx.viewport;\n    const originalPanel = viewport.getCurrentPanel()!.getOriginalPanel();\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = originalPanel.getIdenticalPanels()[1];\n    const lapped = Math.abs(originalPanel.getAnchorPosition() - hangerPosition)\n      > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n    return (!ctx.isNextDirection && lapped)\n      ? firstClonedPanel\n      : originalPanel;\n  }\n}\n\nexport default MoveType;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport MoveType from \"./MoveType\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { clamp } from \"../utils\";\n\nclass Snap extends MoveType {\n  protected readonly type: string = MOVE_TYPE.SNAP;\n  protected count: number;\n\n  constructor(count: number) {\n    super();\n    this.count = count;\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, axesEvent, swipeDistance } = ctx;\n    const snapCount = this.count;\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    const currentPanel = viewport.getCurrentPanel()!;\n    const nearestPanel = viewport.getNearestPanel()!;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    const nearestIsCurrent = nearestPanel.getIndex() === currentPanel.getIndex();\n\n    // This can happen when bounce is 0\n    const shouldMoveWhenBounceIs0 = viewport.canSetBoundMode() && nearestIsCurrent;\n    const shouldMoveToAdjacent = !viewport.isOutOfBound()\n      && (swipeDistance <= minimumDistanceToChange || shouldMoveWhenBounceIs0);\n\n    if (snapCount > 1 && eventDelta > minimumDistanceToChange) {\n      return this.findSnappedPanel(ctx);\n    } else if (shouldMoveToAdjacent) {\n      return this.findAdjacentPanel(ctx);\n    } else {\n      return {\n        panel: nearestPanel,\n        duration: viewport.options.duration,\n        destPos: viewport.findEstimatedPosition(nearestPanel),\n        // As swipeDistance holds mouse/touch position change regardless of bounce option value\n        // swipDistance > minimumDistanceToChange can happen in bounce area\n        // Second condition is for handling that.\n        eventType: (swipeDistance <= minimumDistanceToChange)\n          || (viewport.isOutOfBound() && nearestIsCurrent)\n          ? EVENTS.RESTORE\n          : EVENTS.CHANGE,\n      };\n    }\n  }\n\n  protected findSnappedPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, viewport, state, isNextDirection } = ctx;\n\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    const snapCount = this.count;\n    const options = viewport.options;\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const halfGap = options.gap / 2;\n    const estimatedHangerPos = axesEvent.destPos.flick + viewport.getRelativeHangerPosition();\n\n    let panelToMove = viewport.getNearestPanel()!;\n    let cycleIndex = panelToMove.getCloneIndex() + 1; // 0(original) or 1(clone)\n    let passedPanelCount = 0;\n\n    while (passedPanelCount < snapCount) {\n      // Since panelToMove holds also cloned panels, we should use original panel's position\n      const originalPanel = panelToMove.getOriginalPanel();\n      const panelPosition = originalPanel.getPosition() + cycleIndex * scrollAreaSize;\n      const panelSize = originalPanel.getSize();\n\n      const panelNextPosition = panelPosition + panelSize + halfGap;\n      const panelPrevPosition = panelPosition - halfGap;\n\n      // Current panelToMove contains destPos\n      if (\n        (isNextDirection && panelNextPosition > estimatedHangerPos)\n        || (!isNextDirection && panelPrevPosition < estimatedHangerPos)\n      ) {\n        break;\n      }\n\n      const siblingPanel = isNextDirection\n        ? panelToMove.nextSibling\n        : panelToMove.prevSibling;\n      if (!siblingPanel) {\n        break;\n      }\n\n      const panelIndex = panelToMove.getIndex();\n      const siblingIndex = siblingPanel.getIndex();\n      if ((isNextDirection && siblingIndex <= panelIndex)\n        || (!isNextDirection && siblingIndex >= panelIndex)\n      ) {\n        cycleIndex = isNextDirection\n          ? cycleIndex + 1\n          : cycleIndex - 1;\n      }\n      panelToMove = siblingPanel;\n      passedPanelCount += 1;\n    }\n\n    const originalPosition = panelToMove.getOriginalPanel().getPosition();\n\n    if (cycleIndex !== 0) {\n      panelToMove = panelToMove.clone(panelToMove.getCloneIndex(), true);\n      panelToMove.setPosition(originalPosition + cycleIndex * scrollAreaSize);\n    }\n\n    const defaultDuration = viewport.options.duration;\n    const duration = clamp(axesEvent.duration, defaultDuration, defaultDuration * passedPanelCount);\n\n    return {\n      panel: panelToMove,\n      destPos: viewport.findEstimatedPosition(panelToMove),\n      duration,\n      eventType: Math.max(eventDelta, state.delta) > minimumDistanceToChange\n        ? EVENTS.CHANGE\n        : EVENTS.RESTORE,\n    };\n  }\n\n  private findAdjacentPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentIndex = viewport.getCurrentIndex();\n    const currentPanel = viewport.panelManager.get(currentIndex)!;\n    const hangerPosition = viewport.getHangerPosition();\n    const scrollArea = viewport.getScrollArea();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = options.circular\n      && (Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition));\n\n    // If lapped in circular mode, use first cloned panel as base panel\n    const basePanel = lapped\n      ? firstClonedPanel\n      : currentPanel;\n    const basePosition = basePanel.getPosition();\n\n    const adjacentPanel = isNextDirection\n      ? basePanel.nextSibling\n      : basePanel.prevSibling;\n\n    const eventType = adjacentPanel\n      ? EVENTS.CHANGE\n      : EVENTS.RESTORE;\n    const panelToMove = adjacentPanel\n      ? adjacentPanel\n      : basePanel;\n    const targetRelativeAnchorPosition = panelToMove.getRelativeAnchorPosition();\n\n    const estimatedPanelPosition = options.circular\n      ? isNextDirection\n        ? basePosition + basePanel.getSize() + targetRelativeAnchorPosition + options.gap\n        : basePosition - (panelToMove.getSize() - targetRelativeAnchorPosition) - options.gap\n      : panelToMove.getAnchorPosition();\n    const estimatedPosition = estimatedPanelPosition - viewport.getRelativeHangerPosition();\n    const destPos = viewport.canSetBoundMode()\n      ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next)\n      : estimatedPosition;\n\n    return {\n      panel: panelToMove,\n      destPos,\n      duration: options.duration,\n      eventType,\n    };\n  }\n}\n\nexport default Snap;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Snap from \"./Snap\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { circulate, clamp } from \"../utils\";\n\nclass FreeScroll extends Snap {\n  protected readonly type: string = MOVE_TYPE.FREE_SCROLL;\n\n  constructor() {\n    // Set snap count to Infinity\n    super(Infinity);\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, state, viewport } = ctx;\n    const destPos = axesEvent.destPos.flick;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n    const scrollArea = viewport.getScrollArea();\n    const currentPanel = viewport.getCurrentPanel()!;\n    const options = viewport.options;\n\n    const delta = Math.abs(axesEvent.delta.flick + state.delta);\n    if (delta > minimumDistanceToChange) {\n      const destInfo = super.findSnappedPanel(ctx);\n\n      destInfo.duration = axesEvent.duration;\n      destInfo.destPos = destPos;\n      destInfo.eventType = !options.circular && destInfo.panel === currentPanel\n        ? \"\"\n        : EVENTS.CHANGE;\n\n      return destInfo;\n    } else {\n      let estimatedPosition = options.circular\n        ? circulate(destPos, scrollArea.prev, scrollArea.next, false)\n        : destPos;\n      estimatedPosition = clamp(estimatedPosition, scrollArea.prev, scrollArea.next);\n      estimatedPosition += viewport.getRelativeHangerPosition();\n\n      const estimatedPanel = viewport.findNearestPanelAt(estimatedPosition)!;\n\n      return {\n        panel: estimatedPanel,\n        destPos,\n        duration: axesEvent.duration,\n        eventType: \"\",\n      };\n    }\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    return this.findTargetPanel(ctx);\n  }\n\n  public findPanelWhenInterrupted(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport } = ctx;\n\n    return {\n      panel: viewport.getNearestPanel()!,\n      destPos: viewport.getCameraPosition(),\n      duration: 0,\n      eventType: \"\",\n    };\n  }\n\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const lastPosition = viewport.stateMachine.getState().lastPosition;\n    const currentPanelPosition = currentPanel.getPosition();\n\n    // As camera can stop anywhere in free scroll mode,\n    // minimumDistanceToChange should be calculated differently.\n    // Ref #191(https://github.com/naver/egjs-flicking/issues/191)\n    const lastHangerPosition = lastPosition + viewport.getRelativeHangerPosition();\n\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanelPosition + currentPanel.getSize() - lastHangerPosition + halfGap\n      : lastHangerPosition - currentPanelPosition + halfGap;\n    minimumDistanceToChange = Math.abs(minimumDistanceToChange % scrollAreaSize);\n\n    return Math.min(minimumDistanceToChange, scrollAreaSize - minimumDistanceToChange);\n  }\n}\n\nexport default FreeScroll;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Axes, { PanInput } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport Panel from \"./Panel\";\nimport PanelManager from \"./PanelManager\";\nimport StateMachine from \"./StateMachine\";\nimport MoveType from \"../moves/MoveType\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus, ElementLike, EventType, TriggerCallback, NeedPanelEvent, FlickingEvent, MoveTypeObjectOption, OriginalStyle, Plugin, DestroyOption, BoundingBox } from \"../types\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS, EVENTS, DIRECTION, STATE_TYPE, MOVE_TYPE } from \"../consts\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray, parseElement, hasClass, restoreStyle, circulate, findIndex, getBbox } from \"../utils\";\nimport Snap from \"../moves/Snap\";\nimport FreeScroll from \"../moves/FreeScroll\";\n\nexport default class Viewport {\n  public options: FlickingOptions;\n  public stateMachine: StateMachine;\n  public panelManager: PanelManager;\n  public moveType: MoveType;\n\n  private flicking: Flicking;\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private triggerEvent: Flicking[\"triggerEvent\"];\n  private axesHandlers: { [key: string]: any };\n\n  private currentPanel: Panel | undefined;\n  private nearestPanel: Panel | undefined;\n  private visiblePanels: Panel[];\n\n  private plugins: Plugin[] = [];\n  private panelBboxes: { [className: string]: BoundingBox };\n  private state: {\n    size: number;\n    position: number;\n    panelMaintainRatio: number;\n    relativeHangerPosition: number;\n    positionOffset: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    infiniteThreshold: number;\n    checkedIndexes: Array<[number, number]>;\n    visibleIndex: {\n      min: number;\n      max: number;\n    };\n    isAdaptiveCached: boolean;\n    isViewportGiven: boolean;\n    isCameraGiven: boolean;\n    originalViewportStyle: OriginalStyle;\n    originalCameraStyle: OriginalStyle;\n    cachedBbox: BoundingBox | null;\n  };\n\n  constructor(\n    flicking: Flicking,\n    options: FlickingOptions,\n    triggerEvent: Flicking[\"triggerEvent\"],\n  ) {\n    this.flicking = flicking;\n    this.triggerEvent = triggerEvent;\n\n    this.state = {\n      size: 0,\n      position: 0,\n      panelMaintainRatio: 0,\n      relativeHangerPosition: 0,\n      positionOffset: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      visibleIndex: {\n        min: NaN,\n        max: NaN,\n      },\n      translate: TRANSFORM,\n      infiniteThreshold: 0,\n      checkedIndexes: [],\n      isAdaptiveCached: false,\n      isViewportGiven: false,\n      isCameraGiven: false,\n      originalViewportStyle: {\n        className: null,\n        style: null,\n      },\n      originalCameraStyle: {\n        className: null,\n        style: null,\n      },\n      cachedBbox: null,\n    };\n    this.options = options;\n    this.stateMachine = new StateMachine();\n    this.visiblePanels = [];\n    this.panelBboxes = {};\n\n    this.build();\n  }\n\n  public moveTo(\n    panel: Panel,\n    destPos: number,\n    eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | \"\",\n    axesEvent: any,\n    duration: number = this.options.duration,\n  ): TriggerCallback {\n    const state = this.state;\n    const currentState = this.stateMachine.getState();\n    const currentPosition = state.position;\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const direction = destPos === currentPosition\n      ? null\n      : destPos > currentPosition\n        ? DIRECTION.NEXT\n        : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.getIndex(),\n        panel,\n        direction,\n      });\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      currentState.delta = 0;\n      currentState.lastPosition = this.getCameraPosition();\n      currentState.targetPanel = panel;\n      currentState.direction = destPos === currentPosition\n        ? null\n        : destPos > currentPosition\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      if (destPos === currentPosition) {\n        // no move\n        this.nearestPanel = panel;\n        this.currentPanel = panel;\n      }\n\n      if (axesEvent && axesEvent.setTo) {\n        // freeScroll only occurs in release events\n        axesEvent.setTo({ flick: destPos }, duration);\n      } else {\n        this.axes.setTo({ flick: destPos }, duration);\n      }\n    });\n\n    return eventResult;\n  }\n\n  public moveCamera(pos: number, axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const transform = state.translate.name;\n    const scrollArea = state.scrollArea;\n\n    // Update position & nearestPanel\n    if (options.circular && !isBetween(pos, scrollArea.prev, scrollArea.next)) {\n      pos = circulate(pos, scrollArea.prev, scrollArea.next, false);\n    }\n    state.position = pos;\n    this.nearestPanel = this.findNearestPanel();\n    const nearestPanel = this.nearestPanel;\n    const originalNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    // From 0(panel position) to 1(panel position + panel size)\n    // When it's on gap area value will be (val > 1 || val < 0)\n    if (nearestPanel) {\n      const hangerPosition = this.getHangerPosition();\n      const panelPosition = nearestPanel.getPosition();\n      const panelSize = nearestPanel.getSize();\n      const halfGap = options.gap / 2;\n\n      // As panel's range is from panel position - half gap ~ panel pos + panel size + half gap\n      state.panelMaintainRatio = (hangerPosition - panelPosition + halfGap) / (panelSize + 2 * halfGap);\n    } else {\n      state.panelMaintainRatio = 0;\n    }\n\n    this.checkNeedPanel(axesEvent);\n\n    // Possibly modified after need panel, if it's looped\n    const modifiedNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    pos += (modifiedNearestPosition - originalNearestPosition);\n    state.position = pos;\n\n    this.updateVisiblePanels();\n\n    // Offset is needed to fix camera layer size in visible-only rendering mode\n    const posOffset = options.renderOnlyVisible\n      ? state.positionOffset\n      : 0;\n    const moveVector = options.horizontal\n      ? [-(pos - posOffset), 0] : [0, -(pos - posOffset)];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n  }\n\n  public stopCamera = (axesEvent: any): void => {\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: this.state.position }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  public unCacheBbox(): void {\n    const state = this.state;\n    const options = this.options;\n\n    state.cachedBbox = null;\n    state.visibleIndex = { min: NaN, max: NaN };\n\n    const viewportElement = this.viewportElement;\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n    } else {\n      viewportElement.style.height = \"\";\n    }\n    state.isAdaptiveCached = false;\n    this.panelBboxes = {};\n  }\n\n  public resize(): void {\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n    this.updateClonePanels();\n    this.updateCameraPosition();\n    this.updatePlugins();\n  }\n\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const hangerPosition = this.getHangerPosition();\n\n    if (this.isOutOfBound()) {\n      const position = state.position;\n\n      return position <= state.scrollArea.prev\n        ? panelManager.firstPanel()\n        : panelManager.lastPanel();\n    }\n\n    return this.findNearestPanelAt(hangerPosition);\n  }\n\n  public findNearestPanelAt(position: number): Panel | undefined {\n    const panelManager = this.panelManager;\n\n    const allPanels = panelManager.allPanels();\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel | undefined;\n\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(position, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - position),\n          Math.abs(nextPosition - position),\n        );\n\n      if (distance > minimumDistance) {\n        break;\n      } else if (distance === minimumDistance) {\n        const minimumAnchorDistance = Math.abs(position - nearestPanel!.getAnchorPosition());\n        const anchorDistance = Math.abs(position - panel.getAnchorPosition());\n\n        if (anchorDistance > minimumAnchorDistance) {\n          break;\n        }\n      }\n\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel;\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = this.getHangerPosition();\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = this.getHangerPosition();\n    const distance = Math.abs(hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.relativeHangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.relativeHangerPosition\n        : anchorPosition > hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.relativeHangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.relativeHangerPosition + scrollAreaSize;\n    }\n  }\n\n  public findEstimatedPosition(panel: Panel): number {\n    const scrollArea = this.getScrollArea();\n\n    let estimatedPosition = panel.getAnchorPosition() - this.getRelativeHangerPosition();\n    estimatedPosition = this.canSetBoundMode()\n      ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next)\n      : estimatedPosition;\n\n    return estimatedPosition;\n  }\n\n  public addVisiblePanel(panel: Panel): void {\n    if (this.getVisibleIndexOf(panel) < 0) {\n      this.visiblePanels.push(panel);\n    }\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public insert(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const lastIndex = this.panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const options = this.options;\n    const parsedElements = parseElement(element);\n\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const pushedIndex = this.panelManager.insert(index, panels);\n\n    // ...then calc bbox for all panels\n    this.resizePanels(panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n      this.nearestPanel = panels[0];\n\n      const newCenterPanel = panels[0];\n      const newPanelPosition = this.findEstimatedPosition(newCenterPanel);\n      state.position = newPanelPosition;\n      this.updateAxesPosition(newPanelPosition);\n      state.panelMaintainRatio = (newCenterPanel.getRelativeAnchorPosition() + options.gap / 2) / (newCenterPanel.getSize() + options.gap);\n    }\n\n    // Update checked indexes in infinite mode\n    this.updateCheckedIndexes({ min: index, max: index });\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      if (index < min) {\n        // Push checked index\n        state.checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n      }\n    });\n\n    // Uncache visible index to refresh panels\n    state.visibleIndex = {\n      min: NaN,\n      max: NaN,\n    };\n\n    this.resize();\n\n    return panels;\n  }\n\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const lastIndex = panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const parsedElements = parseElement(element);\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const replacedPanels = panelManager.replace(index, panels);\n\n    replacedPanels.forEach(panel => {\n      const visibleIndex = this.getVisibleIndexOf(panel);\n      if (visibleIndex > -1) {\n        this.visiblePanels.splice(visibleIndex, 1);\n      }\n    });\n\n    // ...then calc bbox for all panels\n    this.resizePanels(panels);\n\n    const currentPanel = this.currentPanel;\n    const wasEmpty = !currentPanel;\n    if (wasEmpty) {\n      this.currentPanel = panels[0];\n      this.nearestPanel = panels[0];\n\n      const newCenterPanel = panels[0];\n      const newPanelPosition = this.findEstimatedPosition(newCenterPanel);\n      state.position = newPanelPosition;\n      this.updateAxesPosition(newPanelPosition);\n      state.panelMaintainRatio = (newCenterPanel.getRelativeAnchorPosition() + options.gap / 2) / (newCenterPanel.getSize() + options.gap);\n    } else if (isBetween(currentPanel!.getIndex(), index, index + panels.length - 1)) {\n      // Current panel is replaced\n      this.currentPanel = panelManager.get(currentPanel!.getIndex());\n    }\n\n    // Update checked indexes in infinite mode\n    this.updateCheckedIndexes({ min: index, max: index + panels.length - 1 });\n\n    // Uncache visible index to refresh panels\n    state.visibleIndex = {\n      min: NaN,\n      max: NaN,\n    };\n\n    this.resize();\n\n    return panels;\n  }\n\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    const state = this.state;\n    // Index should not below 0\n    index = Math.max(index, 0);\n\n    const panelManager = this.panelManager;\n    const currentIndex = this.getCurrentIndex();\n\n    const removedPanels = panelManager.remove(index, deleteCount);\n    if (isBetween(currentIndex, index, index + deleteCount - 1)) {\n      // Current panel is removed\n      // Use panel at removing index - 1 as new current panel if it exists\n      const newCurrentIndex = Math.max(index - 1, panelManager.getRange().min);\n      this.currentPanel = panelManager.get(newCurrentIndex);\n    }\n\n    // Update checked indexes in infinite mode\n    if (deleteCount > 0) {\n      // Check whether removing index will affect checked indexes\n      // Suppose index 0 is empty and removed index 1, then checked index 0 should be deleted and vice versa.\n      this.updateCheckedIndexes({ min: index - 1, max: index + deleteCount });\n      // Uncache visible index to refresh panels\n      state.visibleIndex = {\n        min: NaN,\n        max: NaN,\n      };\n    }\n\n    if (panelManager.getPanelCount() <= 0) {\n      this.currentPanel = undefined;\n      this.nearestPanel = undefined;\n    }\n\n    this.resize();\n\n    const scrollArea = state.scrollArea;\n    if (state.position < scrollArea.prev || state.position > scrollArea.next) {\n      const newPosition = circulate(state.position, scrollArea.prev, scrollArea.next, false);\n      this.moveCamera(newPosition);\n      this.updateAxesPosition(newPosition);\n    }\n\n    return removedPanels;\n  }\n\n  public updateAdaptiveSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const horizontal = options.horizontal;\n    const currentPanel = this.getCurrentPanel();\n\n    if (!currentPanel) {\n      return;\n    }\n\n    const shouldApplyAdaptive = options.adaptive || !state.isAdaptiveCached;\n    const viewportStyle = this.viewportElement.style;\n    if (shouldApplyAdaptive) {\n      let sizeToApply: number;\n      if (options.adaptive) {\n        const panelBbox = currentPanel.getBbox();\n\n        sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n      } else {\n        // Find minimum height of panels to maximum panel size\n        const maximumPanelSize = this.panelManager.originalPanels().reduce((maximum, panel) => {\n          const panelBbox = panel.getBbox();\n          return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n        }, 0);\n\n        sizeToApply = maximumPanelSize;\n      }\n\n      const viewportBbox = this.updateBbox();\n      sizeToApply = Math.max(sizeToApply, horizontal ? viewportBbox.height : viewportBbox.width);\n\n      state.isAdaptiveCached = true;\n      const viewportSize = `${sizeToApply}px`;\n      if (horizontal) {\n        viewportStyle.height = viewportSize;\n        state.cachedBbox!.height = sizeToApply;\n      } else {\n        viewportStyle.width = viewportSize;\n        state.cachedBbox!.width = sizeToApply;\n      }\n    }\n  }\n\n  public updateBbox(): BoundingBox {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n\n    if (!state.cachedBbox) {\n      state.cachedBbox = getBbox(viewportElement, options.useOffset);\n    }\n\n    return state.cachedBbox!;\n  }\n\n  public updatePlugins(): void {\n    // update for resize\n    this.plugins.forEach(plugin => {\n      plugin.update && plugin.update(this.flicking);\n    });\n  }\n\n  public destroy(option: Partial<DestroyOption>): void {\n    const state = this.state;\n    const wrapper = this.flicking.getElement();\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const originalPanels = this.panelManager.originalPanels();\n\n    this.removePlugins(this.plugins);\n    if (!option.preserveUI) {\n      restoreStyle(viewportElement, state.originalViewportStyle);\n      restoreStyle(cameraElement, state.originalCameraStyle);\n\n      if (!state.isCameraGiven && !this.options.renderExternal) {\n        const topmostElement = state.isViewportGiven\n          ? viewportElement\n          : wrapper;\n        const deletingElement = state.isViewportGiven\n          ? cameraElement\n          : viewportElement;\n\n        originalPanels.forEach(panel => {\n          topmostElement.appendChild(panel.getElement());\n        });\n\n        topmostElement.removeChild(deletingElement);\n      }\n    }\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    originalPanels.forEach(panel => { panel.destroy(option); });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const defaultIndex = this.options.defaultIndex;\n    const cameraElement = this.cameraElement;\n    const panelManager = this.panelManager;\n\n    // Restore index\n    cameraElement.innerHTML = panels.map(panel => panel.html).join(\"\");\n\n    // Create panels first\n    this.refreshPanels();\n    const createdPanels = panelManager.originalPanels();\n\n    // ...then order it by its index\n    const orderedPanels: Panel[] = [];\n    panels.forEach((panel, idx) => {\n      const createdPanel = createdPanels[idx];\n      createdPanel.setIndex(panel.index);\n      orderedPanels[panel.index] = createdPanel;\n    });\n    panelManager.replacePanels(orderedPanels, []);\n    panelManager.setCloneCount(0); // No clones at this point\n\n    const panelCount = panelManager.getPanelCount();\n    if (panelCount > 0) {\n      this.currentPanel = panelManager.get(status.index)\n        || panelManager.get(defaultIndex)\n        || panelManager.firstPanel();\n      this.nearestPanel = this.currentPanel;\n    } else {\n      this.currentPanel = undefined;\n      this.nearestPanel = undefined;\n    }\n    this.visiblePanels = orderedPanels.filter(panel => Boolean(panel));\n\n    this.resize();\n\n    this.axes.setTo({ flick: status.position }, 0);\n    this.moveCamera(status.position);\n  }\n\n  public calcVisiblePanels(): Panel[] {\n    const allPanels = this.panelManager.allPanels();\n    if (this.options.renderOnlyVisible) {\n      const { min, max } = this.state.visibleIndex;\n      const visiblePanels = min >= 0\n        ? allPanels.slice(min, max + 1)\n        : allPanels.slice(0, max + 1).concat(allPanels.slice(min));\n\n      return visiblePanels.filter(panel => panel);\n    } else {\n      return allPanels.filter(panel => {\n        const outsetProgress = panel.getOutsetProgress();\n\n        return outsetProgress > -1 && outsetProgress < 1;\n      });\n    }\n  }\n\n  public getCurrentPanel(): Panel | undefined {\n    return this.currentPanel;\n  }\n\n  public getCurrentIndex(): number {\n    const currentPanel = this.currentPanel;\n\n    return currentPanel\n      ? currentPanel.getIndex()\n      : -1;\n  }\n\n  public getNearestPanel(): Panel | undefined {\n    return this.nearestPanel;\n  }\n\n  // Get progress from nearest panel\n  public getCurrentProgress(): number {\n    const currentState = this.stateMachine.getState();\n    let nearestPanel = currentState.playing || currentState.holding\n      ? this.nearestPanel\n      : this.currentPanel;\n\n    const panelManager = this.panelManager;\n    if (!nearestPanel) {\n      // There're no panels\n      return NaN;\n    }\n    const { prev: prevRange, next: nextRange } = this.getScrollArea();\n    const cameraPosition = this.getCameraPosition();\n    const isOutOfBound = this.isOutOfBound();\n    let prevPanel = nearestPanel.prevSibling;\n    let nextPanel = nearestPanel.nextSibling;\n    let hangerPosition = this.getHangerPosition();\n    let nearestAnchorPos = nearestPanel.getAnchorPosition();\n\n    if (\n      isOutOfBound\n      && prevPanel\n      && nextPanel\n      && cameraPosition < nextRange\n      // On the basis of anchor, prevPanel is nearestPanel.\n      && (hangerPosition - prevPanel.getAnchorPosition() < nearestAnchorPos - hangerPosition)\n    ) {\n      nearestPanel = prevPanel;\n      nextPanel = nearestPanel.nextSibling;\n      prevPanel = nearestPanel.prevSibling;\n      nearestAnchorPos = nearestPanel.getAnchorPosition();\n    }\n    const nearestIndex = nearestPanel.getIndex() + (nearestPanel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    const nearestSize = nearestPanel.getSize();\n\n    if (isOutOfBound) {\n      const relativeHangerPosition = this.getRelativeHangerPosition();\n\n      if (nearestAnchorPos > nextRange + relativeHangerPosition) {\n        // next bounce area: hangerPosition - relativeHangerPosition - nextRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - nextRange;\n      } else if (nearestAnchorPos < prevRange + relativeHangerPosition) {\n        // prev bounce area: hangerPosition - relativeHangerPosition - prevRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - prevRange;\n      }\n    }\n    const hangerIsNextToNearestPanel = hangerPosition >= nearestAnchorPos;\n    const gap = this.options.gap;\n\n    let basePosition = nearestAnchorPos;\n    let targetPosition = nearestAnchorPos;\n    if (hangerIsNextToNearestPanel) {\n      targetPosition = nextPanel\n        ? nextPanel.getAnchorPosition()\n        : nearestAnchorPos + nearestSize + gap;\n    } else {\n      basePosition = prevPanel\n        ? prevPanel.getAnchorPosition()\n        : nearestAnchorPos - nearestSize - gap;\n    }\n\n    const progressBetween = (hangerPosition - basePosition) / (targetPosition - basePosition);\n    const startIndex = hangerIsNextToNearestPanel\n      ? nearestIndex\n      : prevPanel\n        ? prevPanel.getIndex()\n        : nearestIndex - 1;\n\n    return startIndex + progressBetween;\n  }\n\n  // Update axes flick position without triggering event\n  public updateAxesPosition(position: number) {\n    const axes = this.axes;\n    axes.off();\n    axes.setTo({\n      flick: position,\n    }, 0);\n    axes.on(this.axesHandlers);\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n\n  public isOutOfBound(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const scrollArea = state.scrollArea;\n\n    return !options.circular\n      && options.bound\n      && (state.position <= scrollArea.prev || state.position >= scrollArea.next);\n  }\n\n  public canSetBoundMode(): boolean {\n    const options = this.options;\n\n    return options.bound && !options.circular;\n  }\n\n  public getViewportElement(): HTMLElement {\n    return this.viewportElement;\n  }\n\n  public getCameraElement(): HTMLElement {\n    return this.cameraElement;\n  }\n\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getRelativeHangerPosition(): number {\n    return this.state.relativeHangerPosition;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.position + this.state.relativeHangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public getPositionOffset(): number {\n    return this.state.positionOffset;\n  }\n\n  public getCheckedIndexes(): Array<[number, number]> {\n    return this.state.checkedIndexes;\n  }\n\n  public getVisibleIndex(): { min: number; max: number } {\n    return this.state.visibleIndex;\n  }\n\n  public getVisiblePanels(): Panel[] {\n    return this.visiblePanels;\n  }\n\n  public setCurrentPanel(panel: Panel): void {\n    this.currentPanel = panel;\n  }\n\n  public setLastIndex(index: number): void {\n    const currentPanel = this.currentPanel;\n    const panelManager = this.panelManager;\n\n    panelManager.setLastIndex(index);\n    if (currentPanel && currentPanel.getIndex() > index) {\n      this.currentPanel = panelManager.lastPanel();\n    }\n\n    this.resize();\n  }\n\n  public setVisiblePanels(panels: Panel[]): void {\n    this.visiblePanels = panels;\n  }\n\n  public connectAxesHandler(handlers: { [key: string]: (event: { [key: string]: any; }) => any }): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handlers;\n    axes.on(handlers);\n  }\n\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this.flicking);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      if (index > -1) {\n        currentPlugins.splice(index, 1);\n      }\n\n      plugin.destroy(this.flicking);\n    });\n    return this;\n  }\n\n  public updateCheckedIndexes(changedRange: { min: number, max: number }): void {\n    const state = this.state;\n\n    let removed = 0;\n    state.checkedIndexes.concat().forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (changedRange.min <= max && changedRange.max >= min) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx - removed, 1);\n        removed++;\n      }\n    });\n  }\n\n  public resetVisibleIndex(): void {\n    const visibleIndex = this.state.visibleIndex;\n    visibleIndex.min = NaN;\n    visibleIndex.max = NaN;\n  }\n\n  public appendUncachedPanelElements(panels: Panel[]): void {\n    const options = this.options;\n    const fragment = document.createDocumentFragment();\n\n    if (options.isEqualSize) {\n      const prevVisiblePanels = this.visiblePanels;\n      const equalSizeClasses = options.isEqualSize as string[]; // for readability\n      const cached: { [className: string]: boolean } = {};\n\n      this.visiblePanels = [];\n\n      Object.keys(this.panelBboxes).forEach(className => {\n        cached[className] = true;\n      });\n\n      panels.forEach(panel => {\n        const overlappedClass = panel.getOverlappedClass(equalSizeClasses);\n        if (overlappedClass && !cached[overlappedClass]) {\n          if (!options.renderExternal) {\n            fragment.appendChild(panel.getElement());\n          }\n          this.visiblePanels.push(panel);\n          cached[overlappedClass] = true;\n        } else if (!overlappedClass) {\n          if (!options.renderExternal) {\n            fragment.appendChild(panel.getElement());\n          }\n          this.visiblePanels.push(panel);\n        }\n      });\n      prevVisiblePanels.forEach(panel => {\n        this.addVisiblePanel(panel);\n      });\n    } else {\n      if (!options.renderExternal) {\n        panels.forEach(panel => fragment.appendChild(panel.getElement()));\n      }\n      this.visiblePanels = panels.filter(panel => Boolean(panel));\n    }\n\n    if (!options.renderExternal) {\n      this.cameraElement.appendChild(fragment);\n    }\n  }\n\n  private updateClonePanels() {\n    const panelManager = this.panelManager;\n\n    // Clone panels in circular mode\n    if (this.options.circular && panelManager.getPanelCount() > 0) {\n      this.clonePanels();\n      this.updateClonedPanelPositions();\n    }\n    panelManager.chainAllPanels();\n  }\n\n  private getVisibleIndexOf(panel: Panel): number {\n    return findIndex(this.visiblePanels, visiblePanel => visiblePanel === panel);\n  }\n\n  private build(): void {\n    this.setElements();\n    this.applyCSSValue();\n    this.setMoveType();\n    this.setAxesInstance();\n    this.refreshPanels();\n    this.setDefaultPanel();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private setElements(): void {\n    const state = this.state;\n    const options = this.options;\n    const wrapper = this.flicking.getElement();\n    const classPrefix = options.classPrefix;\n\n    const viewportCandidate = wrapper.children[0] as HTMLElement;\n    const hasViewportElement = viewportCandidate && hasClass(viewportCandidate, `${classPrefix}-viewport`);\n\n    const viewportElement = hasViewportElement\n      ? viewportCandidate\n      : document.createElement(\"div\");\n\n    const cameraCandidate = hasViewportElement\n      ? viewportElement.children[0] as HTMLElement\n      : wrapper.children[0] as HTMLElement;\n    const hasCameraElement = cameraCandidate && hasClass(cameraCandidate, `${classPrefix}-camera`);\n\n    const cameraElement = hasCameraElement\n      ? cameraCandidate\n      : document.createElement(\"div\");\n\n    if (!hasCameraElement) {\n      cameraElement.className = `${classPrefix}-camera`;\n\n      const panelElements = hasViewportElement\n        ? viewportElement.children\n        : wrapper.children;\n\n      // Make all panels to be a child of camera element\n      // wrapper <- viewport <- camera <- panels[1...n]\n      toArray(panelElements).forEach(child => {\n        cameraElement.appendChild(child);\n      });\n    } else {\n      state.originalCameraStyle = {\n        className: cameraElement.getAttribute(\"class\"),\n        style: cameraElement.getAttribute(\"style\"),\n      };\n    }\n\n    if (!hasViewportElement) {\n      viewportElement.className = `${classPrefix}-viewport`;\n\n      // Add viewport element to wrapper\n      wrapper.appendChild(viewportElement);\n    } else {\n      state.originalViewportStyle = {\n        className: viewportElement.getAttribute(\"class\"),\n        style: viewportElement.getAttribute(\"style\"),\n      };\n    }\n\n    if (!hasCameraElement || !hasViewportElement) {\n      viewportElement.appendChild(cameraElement);\n    }\n\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n    state.isViewportGiven = hasViewportElement;\n    state.isCameraGiven = hasCameraElement;\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const viewportStyle = this.viewportElement.style;\n\n    // Set default css values for each element\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    viewportElement.style.zIndex = `${options.zIndex}`;\n    if (options.horizontal) {\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n    if (options.overflow) {\n      viewportStyle.overflow = \"visible\";\n    }\n\n    this.panelManager = new PanelManager(this.cameraElement, options);\n  }\n\n  private setMoveType(): void {\n    const moveType = this.options.moveType as MoveTypeObjectOption;\n\n    switch (moveType.type) {\n      case MOVE_TYPE.SNAP:\n        this.moveType = new Snap(moveType.count);\n        break;\n      case MOVE_TYPE.FREE_SCROLL:\n        this.moveType = new FreeScroll();\n        break;\n      default:\n        throw new Error(\"moveType is not correct!\");\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n    const horizontal = options.horizontal;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n    });\n\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  private refreshPanels(): void {\n    const panelManager = this.panelManager;\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n\n    // Initialize panels\n    const panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this),\n    );\n\n    panelManager.replacePanels(panels, []);\n    this.visiblePanels = panels.filter(panel => Boolean(panel));\n  }\n\n  private setDefaultPanel(): void {\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const indexRange = this.panelManager.getRange();\n    const index = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n\n    this.currentPanel = panelManager.get(index);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n\n    const gap = options.gap;\n    const viewportSize = state.size;\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    // There're no panels exist\n    if (!firstPanel) {\n      return;\n    }\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const panels = panelManager.originalPanels();\n    const reversedPanels = panels.concat().reverse();\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + gap;\n    const relativeAnchorPosition = firstPanel.getRelativeAnchorPosition();\n    const relativeHangerPosition = this.getRelativeHangerPosition();\n\n    const areaPrev = (relativeHangerPosition - relativeAnchorPosition) % sumOriginalPanelSize;\n    let sizeSum = 0;\n    let panelAtLeftBoundary!: Panel;\n    for (const panel of reversedPanels) {\n      if (!panel) {\n        continue;\n      }\n      sizeSum += panel.getSize() + gap;\n      if (sizeSum >= areaPrev) {\n        panelAtLeftBoundary = panel;\n        break;\n      }\n    }\n\n    const areaNext = (viewportSize - relativeHangerPosition + relativeAnchorPosition) % sumOriginalPanelSize;\n    sizeSum = 0;\n    let panelAtRightBoundary!: Panel;\n    for (const panel of panels) {\n      if (!panel) {\n        continue;\n      }\n      sizeSum += panel.getSize() + gap;\n      if (sizeSum >= areaNext) {\n        panelAtRightBoundary = panel;\n        break;\n      }\n    }\n\n    // Need one more set of clones on prev area of original panel 0\n    const needCloneOnPrev = panelAtLeftBoundary.getIndex() !== 0\n      && panelAtLeftBoundary.getIndex() <= panelAtRightBoundary.getIndex();\n\n    // Visible count of panel 0 on first screen\n    const panel0OnFirstscreen = Math.ceil((relativeHangerPosition + firstPanel.getSize() - relativeAnchorPosition) / sumOriginalPanelSize)\n      + Math.ceil((viewportSize - relativeHangerPosition + relativeAnchorPosition) / sumOriginalPanelSize)\n      - 1; // duplication\n\n    const cloneCount = panel0OnFirstscreen\n      + (needCloneOnPrev ? 1 : 0);\n    const prevCloneCount = panelManager.getCloneCount();\n\n    panelManager.setCloneCount(cloneCount);\n    if (options.renderExternal) {\n      return;\n    }\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        const clones = panels.map(origPanel => origPanel.clone(cloneIndex));\n        const fragment = document.createDocumentFragment();\n        clones.forEach(panel => fragment.appendChild(panel.getElement()));\n\n        this.cameraElement.appendChild(fragment);\n        this.visiblePanels.push(...clones.filter(clone => Boolean(clone)));\n        panelManager.insertClones(cloneIndex, 0, clones);\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panelManager.removeClonesAfter(cloneCount);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const indexRange = this.panelManager.getRange();\n\n    const defaultIndex = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    const defaultPanel = panelManager.get(defaultIndex);\n\n    let defaultPosition = 0;\n    if (defaultPanel) {\n      defaultPosition = defaultPanel.getAnchorPosition() - state.relativeHangerPosition;\n      defaultPosition = this.canSetBoundMode()\n        ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n        : defaultPosition;\n    }\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const panels = this.panelManager.originalPanels()\n      .filter(panel => Boolean(panel));\n    const bbox = this.updateBbox();\n\n    const prevSize = state.size;\n    // Update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    if (prevSize !== state.size) {\n      state.relativeHangerPosition = parseArithmeticExpression(options.hanger, state.size);\n      state.infiniteThreshold = parseArithmeticExpression(options.infiniteThreshold, state.size);\n    }\n\n    if (panels.length <= 0) {\n      return;\n    }\n\n    this.resizePanels(panels);\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panelManager = this.panelManager;\n\n    const firstPanel = panelManager.firstPanel();\n    const panels = panelManager.originalPanels();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const currentPanel = this.currentPanel!;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n    const scrollArea = this.state.scrollArea;\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = firstPanel.getPosition();\n    let maintainingPanel: Panel = firstPanel;\n    if (nearestPanel) {\n      // We should maintain nearestPanel's position\n      const looped = !isBetween(currentState.lastPosition + currentState.delta, scrollArea.prev, scrollArea.next);\n\n      maintainingPanel = looped\n        ? currentPanel\n        : nearestPanel;\n    } else if (firstPanel.getIndex() > 0) {\n      maintainingPanel = currentPanel;\n    }\n\n    const panelsBeforeMaintainPanel = panels.slice(0, maintainingPanel.getIndex() + (maintainingPanel.getCloneIndex() + 1) * panels.length);\n    const accumulatedSize = panelsBeforeMaintainPanel.reduce((total, panel) => {\n      return total + panel.getSize() + gap;\n    }, 0);\n\n    nextPanelPos = maintainingPanel.getPosition() - accumulatedSize;\n\n    panels.forEach(panel => {\n      const newPosition = nextPanelPos;\n      const panelSize = panel.getSize();\n\n      panel.setPosition(newPosition);\n      nextPanelPos += panelSize + gap;\n    });\n\n    if (!this.options.renderOnlyVisible) {\n      panels.forEach(panel => panel.setPositionCSS());\n    }\n  }\n\n  private updateClonedPanelPositions(): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const clonedPanels = panelManager.clonedPanels()\n      .reduce((allClones, clones) => [...allClones, ...clones], [])\n      .filter(panel => Boolean(panel));\n\n    const scrollArea = state.scrollArea;\n\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      const origPanel = panel.getOriginalPanel();\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (replacePosition + panelSize <= scrollArea.prev) {\n        // Replace is not meaningful, as it won't be seen in current scroll area\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n\n    if (!this.options.renderOnlyVisible) {\n      clonedPanels.forEach(panel => {\n        panel.setPositionCSS();\n      });\n    }\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n    const relativeHangerPosition = state.relativeHangerPosition;\n\n    if (!firstPanel) {\n      state.scrollArea = {\n        prev: 0,\n        next: 0,\n      };\n    } else if (this.canSetBoundMode()) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition();\n\n      if (sumOriginalPanelSize >= state.size) {\n        state.scrollArea = {\n          prev: firstPanel.getPosition(),\n          next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n        };\n      } else {\n        // Find anchor position of set of the combined panels\n        const relAnchorPosOfCombined = parseArithmeticExpression(options.anchor, sumOriginalPanelSize);\n        const anchorPos = firstPanel.getPosition() + clamp(\n          relAnchorPosOfCombined,\n          sumOriginalPanelSize - (state.size - relativeHangerPosition),\n          relativeHangerPosition,\n        );\n\n        state.scrollArea = {\n          prev: anchorPos - relativeHangerPosition,\n          next: anchorPos - relativeHangerPosition,\n        };\n      }\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: sumOriginalPanelSize + firstPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: lastPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    const flick = axes.axis.flick;\n    flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    flick.bounce = parsedBounce;\n  }\n\n  // Update camera position after resizing\n  private updateCameraPosition(): void {\n    const state = this.state;\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.stateMachine.getState();\n    const isFreeScroll = this.moveType.is(MOVE_TYPE.FREE_SCROLL);\n    const relativeHangerPosition = this.getRelativeHangerPosition();\n    const halfGap = this.options.gap / 2;\n\n    if (currentState.holding || currentState.playing) {\n      this.updateVisiblePanels();\n      return;\n    }\n\n    let newPosition: number;\n    if (isFreeScroll) {\n      const nearestPanel = this.getNearestPanel();\n\n      newPosition = nearestPanel\n        ? nearestPanel.getPosition() - halfGap + (nearestPanel.getSize() + 2 * halfGap) * state.panelMaintainRatio - relativeHangerPosition\n        : this.getCameraPosition();\n    } else {\n      newPosition = currentPanel\n        ? currentPanel.getAnchorPosition() - relativeHangerPosition\n        : this.getCameraPosition();\n    }\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    // This should be done before moveCamera, as moveCamera can trigger needPanel\n    this.updateAxesPosition(newPosition);\n\n    this.moveCamera(newPosition);\n  }\n\n  private checkNeedPanel(axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const currentPanel = this.currentPanel;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    if (!options.infinite) {\n      return;\n    }\n\n    const gap = options.gap;\n    const infiniteThreshold = state.infiniteThreshold;\n    const maxLastIndex = panelManager.getLastIndex();\n\n    if (maxLastIndex < 0) {\n      return;\n    }\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      this.triggerNeedPanel({\n        axesEvent,\n        siblingPanel: null,\n        direction: null,\n        indexRange: {\n          min: 0,\n          max: maxLastIndex,\n          length: maxLastIndex + 1,\n        },\n      });\n      return;\n    }\n\n    const originalNearestPosition = nearestPanel.getPosition();\n\n    // Check next direction\n    let checkingPanel: Panel | null = !currentState.holding && !currentState.playing\n      ? currentPanel\n      : nearestPanel;\n\n    while (checkingPanel) {\n      const currentIndex = checkingPanel.getIndex();\n      const nextSibling = checkingPanel.nextSibling;\n      const lastPanel = panelManager.lastPanel()!;\n      const atLastPanel = currentIndex === lastPanel.getIndex();\n      const nextIndex = !atLastPanel && nextSibling\n        ? nextSibling.getIndex()\n        : maxLastIndex + 1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelRight = checkingPanel.getPosition() + checkingPanel.getSize() - (currentNearestPosition - originalNearestPosition);\n      const cameraNext = state.position + state.size;\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = (nextIndex - currentIndex > 1);\n      // Expected prev panel's left position is smaller than camera position\n      const overThreshold = panelRight + gap - infiniteThreshold <= cameraNext;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.NEXT,\n          indexRange: {\n            min: currentIndex + 1,\n            max: nextIndex - 1,\n            length: nextIndex - currentIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at max panel index\n      if (options.circular && currentIndex === maxLastIndex && overThreshold) {\n        const firstPanel = panelManager.firstPanel();\n        const firstIndex = firstPanel\n          ? firstPanel.getIndex()\n          : -1;\n\n        if (firstIndex > 0) {\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.NEXT,\n            indexRange: {\n              min: 0,\n              max: firstIndex - 1,\n              length: firstIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether panels are changed\n      const lastPanelAfterNeed = panelManager.lastPanel()!;\n      const atLastPanelAfterNeed = lastPanelAfterNeed && currentIndex === lastPanelAfterNeed.getIndex();\n\n      if (atLastPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.nextSibling;\n    }\n\n    // Check prev direction\n    checkingPanel = nearestPanel;\n    while (checkingPanel) {\n      const cameraPrev = state.position;\n      const checkingIndex = checkingPanel.getIndex();\n      const prevSibling = checkingPanel.prevSibling;\n      const firstPanel = panelManager.firstPanel()!;\n      const atFirstPanel = checkingIndex === firstPanel.getIndex();\n      const prevIndex = !atFirstPanel && prevSibling\n        ? prevSibling.getIndex()\n        : -1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelLeft = checkingPanel.getPosition() - (currentNearestPosition - originalNearestPosition);\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = checkingIndex - prevIndex > 1;\n      // Expected prev panel's right position is smaller than camera position\n      const overThreshold = panelLeft - gap + infiniteThreshold >= cameraPrev;\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.PREV,\n          indexRange: {\n            min: prevIndex + 1,\n            max: checkingIndex - 1,\n            length: checkingIndex - prevIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at panel 0\n      if (options.circular && checkingIndex === 0 && overThreshold) {\n        const lastPanel = panelManager.lastPanel();\n\n        if (lastPanel && lastPanel.getIndex() < maxLastIndex) {\n          const lastIndex = lastPanel.getIndex();\n\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.PREV,\n            indexRange: {\n              min: lastIndex + 1,\n              max: maxLastIndex,\n              length: maxLastIndex - lastIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether panels were changed\n      const firstPanelAfterNeed = panelManager.firstPanel();\n      const atFirstPanelAfterNeed = firstPanelAfterNeed && checkingIndex === firstPanelAfterNeed.getIndex();\n\n      // Looped in circular mode\n      if (atFirstPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.prevSibling;\n    }\n  }\n\n  private triggerNeedPanel(params: {\n    axesEvent: any;\n    siblingPanel: Panel | null,\n    direction: FlickingEvent[\"direction\"];\n    indexRange: NeedPanelEvent[\"range\"];\n  }): void {\n    const { axesEvent, siblingPanel, direction, indexRange } = params;\n    const options = this.options;\n    const checkedIndexes = this.state.checkedIndexes;\n    const alreadyTriggered = checkedIndexes.some(([min, max]) => min === indexRange.min || max === indexRange.max);\n    const hasHandler = this.flicking.hasOn(EVENTS.NEED_PANEL);\n\n    if (alreadyTriggered || !hasHandler) {\n      return;\n    }\n\n    // Should done before triggering event, as we can directly add panels by event callback\n    checkedIndexes.push([indexRange.min, indexRange.max]);\n\n    const index = siblingPanel\n      ? siblingPanel.getIndex()\n      : 0;\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n\n    this.triggerEvent(\n      EVENTS.NEED_PANEL,\n      axesEvent,\n      isTrusted,\n      {\n        index,\n        panel: siblingPanel,\n        direction,\n        range: indexRange,\n        fill: (element: ElementLike | ElementLike[]) => {\n          const panelManager = this.panelManager;\n          if (!siblingPanel) {\n            return this.insert(panelManager.getRange().max + 1, element);\n          }\n\n          const parsedElements = parseElement(element);\n          // Slice elements to fit size equal to empty spaces\n          const elements = direction === DIRECTION.NEXT\n            ? parsedElements.slice(0, indexRange.length)\n            : parsedElements.slice(-indexRange.length);\n\n          if (direction === DIRECTION.NEXT) {\n            if (options.circular && index === panelManager.getLastIndex()) {\n              // needPanel event is triggered on last index, insert at index 0\n              return this.insert(0, elements);\n            } else {\n              return siblingPanel.insertAfter(elements);\n            }\n          } else if (direction === DIRECTION.PREV) {\n            if (options.circular && index === 0) {\n              // needPanel event is triggered on first index(0), insert at the last index\n              return this.insert(indexRange.max - elements.length + 1, elements);\n            } else {\n              return siblingPanel.insertBefore(elements);\n            }\n          } else {\n            // direction is null when there're no panels exist\n            return this.insert(0, elements);\n          }\n        },\n      } as Partial<NeedPanelEvent>,\n    );\n  }\n\n  private updateVisiblePanels() {\n    const state = this.state;\n    const options = this.options;\n    const cameraElement = this.cameraElement;\n    const visibleIndex = state.visibleIndex;\n    const { renderExternal, renderOnlyVisible } = options;\n    if (!renderOnlyVisible) {\n      return;\n    }\n\n    if (!this.nearestPanel) {\n      this.resetVisibleIndex();\n      while (cameraElement.firstChild) {\n        cameraElement.removeChild(cameraElement.firstChild);\n      }\n      return;\n    }\n\n    const newVisibleIndex = this.calcNewVisiblePanelIndex();\n\n    if (newVisibleIndex.min !== visibleIndex.min || newVisibleIndex.max !== visibleIndex.max) {\n      state.visibleIndex = newVisibleIndex;\n      if (isNaN(newVisibleIndex.min) || isNaN(newVisibleIndex.max)) {\n        return;\n      }\n\n      const prevVisiblePanels = this.visiblePanels;\n      const newVisiblePanels = this.calcVisiblePanels();\n\n      const { addedPanels, removedPanels } = this.checkVisiblePanelChange(prevVisiblePanels, newVisiblePanels);\n\n      if (newVisiblePanels.length > 0) {\n        const firstVisiblePanelPos = newVisiblePanels[0].getPosition();\n        state.positionOffset = firstVisiblePanelPos;\n      }\n\n      newVisiblePanels.forEach(panel => {\n        panel.setPositionCSS(state.positionOffset);\n      });\n\n      if (!renderExternal) {\n        removedPanels.forEach(panel => {\n          const panelElement = panel.getElement();\n          panelElement.parentNode && cameraElement.removeChild(panelElement);\n        });\n\n        const fragment = document.createDocumentFragment();\n        addedPanels.forEach(panel => {\n          fragment.appendChild(panel.getElement());\n        });\n\n        cameraElement.appendChild(fragment);\n      }\n      this.visiblePanels = newVisiblePanels;\n\n      this.flicking.trigger(EVENTS.VISIBLE_CHANGE, {\n        type: EVENTS.VISIBLE_CHANGE,\n        range: {\n          min: newVisibleIndex.min,\n          max: newVisibleIndex.max,\n        },\n      });\n    } else {\n      this.visiblePanels.forEach(panel => panel.setPositionCSS(state.positionOffset));\n    }\n  }\n\n  private calcNewVisiblePanelIndex() {\n    const cameraPos = this.getCameraPosition();\n    const viewportSize = this.getSize();\n    const basePanel = this.nearestPanel!;\n    const panelManager = this.panelManager;\n    const allPanelCount = panelManager.getRange().max + 1;\n    const cloneCount = panelManager.getCloneCount();\n\n    const checkLastPanel = (\n      panel: Panel,\n      getNextPanel: (panel: Panel) => Panel | null,\n      isOutOfViewport: (panel: Panel) => boolean,\n    ): Panel => {\n      let lastPanel = panel;\n      while (true) {\n        const nextPanel = getNextPanel(lastPanel);\n        if (!nextPanel || isOutOfViewport(nextPanel)) {\n          break;\n        }\n        lastPanel = nextPanel;\n      }\n      return lastPanel;\n    };\n\n    const lastPanelOfNextDir = checkLastPanel(basePanel, panel => {\n      const nextPanel = panel.nextSibling;\n\n      if (nextPanel && nextPanel.getPosition() >= panel.getPosition()) {\n        return nextPanel;\n      } else {\n        return null;\n      }\n    }, panel => panel.getPosition() >= cameraPos + viewportSize);\n\n    const lastPanelOfPrevDir = checkLastPanel(basePanel, panel => {\n      const prevPanel = panel.prevSibling;\n\n      if (prevPanel && prevPanel.getPosition() <= panel.getPosition()) {\n        return prevPanel;\n      } else {\n        return null;\n      }\n    }, panel => panel.getPosition() + panel.getSize() <= cameraPos);\n\n    const minPanelCloneIndex = lastPanelOfPrevDir.getCloneIndex();\n    const maxPanelCloneOffset = allPanelCount * (lastPanelOfNextDir.getCloneIndex() + 1);\n    const minPanelCloneOffset = minPanelCloneIndex > -1\n      ? allPanelCount * (cloneCount - minPanelCloneIndex)\n      : 0;\n\n    const newVisibleIndex = {\n      // Relative index including clone, can be negative number\n      min: basePanel.getCloneIndex() > -1\n        ? lastPanelOfPrevDir.getIndex() + minPanelCloneOffset\n        : lastPanelOfPrevDir.getIndex() - minPanelCloneOffset,\n      // Relative index including clone\n      max: lastPanelOfNextDir.getIndex() + maxPanelCloneOffset,\n    };\n\n    // Stopped on first cloned first panel\n    if (lastPanelOfPrevDir.getIndex() === 0 && lastPanelOfPrevDir.getCloneIndex() === 0) {\n      newVisibleIndex.min = allPanelCount;\n    }\n\n    return newVisibleIndex;\n  }\n\n  private checkVisiblePanelChange(prevVisiblePanels: Panel[], newVisiblePanels: Panel[]) {\n    const prevRefCount = prevVisiblePanels.map(() => 0);\n    const newRefCount = newVisiblePanels.map(() => 0);\n\n    prevVisiblePanels.forEach((prevPanel, prevIndex) => {\n      newVisiblePanels.forEach((newPanel, newIndex) => {\n        if (prevPanel === newPanel) {\n          prevRefCount[prevIndex]++;\n          newRefCount[newIndex]++;\n        }\n      });\n    });\n\n    const removedPanels = prevRefCount.reduce((removed: Panel[], count, index) => {\n      return count === 0\n        ? [...removed, prevVisiblePanels[index]]\n        : removed;\n    }, []);\n    const addedPanels = newRefCount.reduce((added: Panel[], count, index) => {\n      return count === 0\n        ? [...added, newVisiblePanels[index]]\n        : added;\n    }, []);\n\n    return { removedPanels, addedPanels };\n  }\n\n  private resizePanels(panels: Panel[]): void {\n    const options = this.options;\n    const panelBboxes = this.panelBboxes;\n\n    if (options.isEqualSize === true) {\n      if (!panelBboxes.default) {\n        const defaultPanel = panels[0];\n        panelBboxes.default = defaultPanel.getBbox();\n      }\n\n      const defaultBbox = panelBboxes.default;\n\n      panels.forEach(panel => {\n        panel.resize(defaultBbox);\n      });\n      return;\n    } else if (options.isEqualSize) {\n      const equalSizeClasses = options.isEqualSize;\n\n      panels.forEach(panel => {\n        const overlappedClass = panel.getOverlappedClass(equalSizeClasses);\n        if (overlappedClass) {\n          panel.resize(panelBboxes[overlappedClass]);\n          panelBboxes[overlappedClass] = panel.getBbox();\n        } else {\n          panel.resize();\n        }\n      });\n      return;\n    }\n    panels.forEach(panel => {\n      panel.resize();\n    });\n  }\n}\n","import { isBrowser } from \"../consts\";\n\nconst tid = \"UA-70842526-24\";\nconst cid = (Math.random() * Math.pow(10, 20)) / Math.pow(10, 10);\n\nexport function sendEvent(category: string, action: string, label: any) {\n  if (!isBrowser) {\n    return;\n  }\n\n  try {\n    const innerWidth = window.innerWidth;\n    const innerHeight = window.innerHeight;\n    const screen = window.screen || { width: innerWidth, height: innerHeight };\n    const collectInfos = [\n      \"v=1\",\n      \"t=event\",\n      `dl=${location.href}`,\n      `ul=${(navigator.language || \"en-us\").toLowerCase()}`,\n      `de=${document.charset || document.inputEncoding || document.characterSet || \"utf-8\"}`,\n      `dr=${document.referrer}`,\n      `dt=${document.title}`,\n      `sr=${screen.width}x${screen.height}`,\n      `vp=${innerWidth}x${innerHeight}`,\n      `ec=${category}`,\n      `ea=${action}`,\n      `el=${JSON.stringify(label)}`,\n      `cid=${cid}`,\n      `tid=${tid}`,\n      \"cd1=#__VERSION__#\",\n      `z=${Math.floor(Math.random() * 10000000)}`,\n    ];\n    const req = new XMLHttpRequest();\n    req.open(\"GET\", `https://www.google-analytics.com/collect?${collectInfos.join(\"&\")}`);\n    req.send();\n  } catch (e) {}\n}\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\nimport Panel from \"./components/Panel\";\n\nimport { merge, getProgress, parseElement, isString, counter, findIndex } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE, DEFAULT_MOVE_TYPE_OPTIONS } from \"./consts\";\nimport {\n  FlickingOptions,\n  FlickingEvent,\n  Direction,\n  EventType,\n  FlickingPanel,\n  TriggerCallback,\n  FlickingContext,\n  FlickingStatus,\n  Plugin,\n  ElementLike,\n  DestroyOption,\n  BeforeSyncResult,\n  SyncResult,\n} from \"./types\";\nimport { sendEvent } from \"./ga/ga\";\nimport { DiffResult } from \"@egjs/list-differ\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @type {object}\n   * @property {\"PREV\"} PREV - Prev direction from current hanger position.<br/>It's `left(←️)` direction when `horizontal: true`.<br/>Or, `up(↑️)` direction when `horizontal: false`.<ko>현재 행어를 기준으로 이전 방향.<br/>`horizontal: true`일 경우 `왼쪽(←️)` 방향.<br/>`horizontal: false`일 경우 `위쪽(↑️)`방향이다.</ko>\n   * @property {\"NEXT\"} NEXT - Next direction from current hanger position.<br/>It's `right(→)` direction when `horizontal: true`.<br/>Or, `down(↓️)` direction when `horizontal: false`.<ko>현재 행어를 기준으로 다음 방향.<br/>`horizontal: true`일 경우 `오른쪽(→)` 방향.<br/>`horizontal: false`일 경우 `아래쪽(↓️)`방향이다.</ko>\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event type object with event name strings.\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   * @type {object}\n   * @property {\"holdStart\"} HOLD_START - holdStart event<ko>holdStart 이벤트</ko>\n   * @property {\"holdEnd\"} HOLD_END - holdEnd event<ko>holdEnd 이벤트</ko>\n   * @property {\"moveStart\"} MOVE_START - moveStart event<ko>moveStart 이벤트</ko>\n   * @property {\"move\"} MOVE - move event<ko>move 이벤트</ko>\n   * @property {\"moveEnd\"} MOVE_END - moveEnd event<ko>moveEnd 이벤트</ko>\n   * @property {\"change\"} CHANGE - change event<ko>change 이벤트</ko>\n   * @property {\"restore\"} RESTORE - restore event<ko>restore 이벤트</ko>\n   * @property {\"select\"} SELECT - select event<ko>select 이벤트</ko>\n   * @property {\"needPanel\"} NEED_PANEL - needPanel event<ko>needPanel 이벤트</ko>\n   * @example\n   * eg.Flicking.EVENTS.MOVE_START; // \"MOVE_START\"\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private eventContext: FlickingContext;\n  private isPanelChangedAtBeforeSync: boolean = false;\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options An option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix of class names will be added for the panels, viewport, and camera.<ko>패널들과 뷰포트, 카메라에 추가될 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation for animation triggered by manual user input. A higher value means a shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] The direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for continuous scrolling.<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능하다.</ko>\n   * @param {boolean} [options.infinite=false] Enables infinite mode, which can automatically trigger needPanel until reaching the last panel's index reaches the lastIndex.<ko>무한 모드를 활성화한다. 무한 모드에서는 needPanel 이벤트를 자동으로 트리거한다. 해당 동작은 마지막 패널의 인덱스가 lastIndex와 일치할때까지 일어난다.</ko>\n   * @param {number} [options.infiniteThreshold=0] A Threshold from viewport edge before triggering `needPanel` event in infinite mode.<ko>무한 모드에서 `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리.</ko>\n   * @param {number} [options.lastIndex=Infinity] Maximum panel index that Flicking can set. Flicking won't trigger `needPanel` when the event's panel index is greater than it.<br/>Also, if the last panel's index reached a given index, you can't add more panels.<ko>Flicking이 설정 가능한 패널의 최대 인덱스. `needPanel` 이벤트에 지정된 인덱스가 최대 패널의 개수보다 같거나 커야 하는 경우에 이벤트를 트리거하지 않게 한다.<br>또한, 마지막 패널의 인덱스가 주어진 인덱스와 동일할 경우, 새로운 패널을 더 이상 추가할 수 없다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to change panel(unit: pixel). It should be dragged above the threshold to change the current panel.<ko>패널 변경을 위한 이동 임계값 (단위: 픽셀). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement animation. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] An easing function applied to the panel movement animation. Default value is `easeOutCubic`.<ko>패널 이동 애니메이션에 적용할 easing함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of the panel to set as default when initializing. A zero-based integer.<ko>초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices to enable.({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Reference})<ko>활성화할 입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 참고})</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold angle value(0 ~ 90).<br>If the input angle from click/touched position is above or below this value in horizontal and vertical mode each, scrolling won't happen.<ko>스크롤 동작을 막기 위한 임계각(0 ~ 90).<br>클릭/터치한 지점으로부터 계산된 사용자 입력의 각도가 horizontal/vertical 모드에서 각각 크거나 작으면, 스크롤 동작이 이루어지지 않는다.</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`.<br>You can set different bounce value for prev/next direction by using array.<br>`number` for px value, and `string` for px, and % value relative to viewport size.(ex - 0, \"10px\", \"20%\")<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.<br>배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정 가능하다.<br>`number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있다.(ex - 0, \"10px\", \"20%\")</ko>\n   * @param {boolean} [options.autoResize=false] Whether the `resize` method should be called automatically after a window resize event.<ko>window의 `resize` 이벤트 이후 자동으로 resize()메소드를 호출할지의 여부.</ko>\n   * @param {boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number|\"\"} [options.zIndex=2000] z-index value for viewport element.<ko>뷰포트 엘리먼트의 z-index 값.</ko>\n   * @param {boolean} [options.bound=false] Prevent the view from going out of the first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] The reference position of the hanger in the viewport, which hangs panel anchors should be stopped at.<br>It should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign.<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] The reference position of the anchor in panels, which can be hanged by viewport hanger.<br>It should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign.<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space value between panels. Should be given in number.(px)<ko>패널간에 부여할 간격의 크기를 나타내는 숫자.(px)</ko>\n   * @param {eg.Flicking.MoveTypeOption} [options.moveType=\"snap\"] Movement style by user input. (ex: snap, freeScroll)<ko>사용자 입력에 의한 이동 방식.(ex: snap, freeScroll)</ko>\n   * @param {boolean} [options.useOffset=false] Whether to use `offsetWidth`/`offsetHeight` instead of `getBoundingClientRect` for panel/viewport size calculation.<br/>You can use this option to calculate the original panel size when CSS transform is applied to viewport or panel.<br/>⚠️ If panel size is not fixed integer value, there can be a 1px gap between panels.<ko>패널과 뷰포트의 크기를 계산할 때 `offsetWidth`/`offsetHeight`를 `getBoundingClientRect` 대신 사용할지 여부.<br/>패널이나 뷰포트에 CSS transform이 설정되어 있을 때 원래 패널 크기를 계산하려면 옵션을 활성화한다.<br/>⚠️ 패널의 크기가 정수로 고정되어있지 않다면 패널 사이에 1px의 공간이 생길 수 있다.</ko>\n   * @param {boolean} [options.renderOnlyVisible] Whether to render visible panels only. This can dramatically increase performance when there're many panels.<ko>보이는 패널만 렌더링할지 여부를 설정한다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있다.</ko>\n   * @param {boolean|string[]} [options.isEqualSize] This option indicates whether all panels have the same size(true) of first panel, or it can hold a list of class names that determines panel size.<br/>Enabling this option can increase performance while recalculating panel size.<ko>모든 패널의 크기가 동일한지(true), 혹은 패널 크기를 결정하는 패널 클래스들의 리스트.<br/>이 옵션을 설정하면 패널 크기 재설정시에 성능을 높일 수 있다.</ko>\n   * @param {boolean} [options.isConstantSize] Whether all panels have a constant size that won't be changed after resize. Enabling this option can increase performance while recalculating panel size.<ko>모든 패널의 크기가 불변인지의 여부. 이 옵션을 'true'로 설정하면 패널 크기 재설정시에 성능을 높일 수 있다.</ko>\n   * @param {boolean} [options.renderExternal] Whether to use external rendering. It will delegate DOM manipulation and can synchronize the rendered state by calling `sync()` method. You can use this option to use in frameworks like React, Vue, Angular, which has its states and rendering methods.<ko>외부 렌더링을 사용할 지의 여부. 이 옵션을 사용시 렌더링을 외부에 위임할 수 있고, `sync()`를 호출하여 그 상태를 동기화할 수 있다. 이 옵션을 사용하여, React, Vue, Angular 등 자체적인 상태와 렌더링 방법을 갖는 프레임워크에 대응할 수 있다.</ko>\n   * @param {boolean} [options.collectStatistics=true] Whether to collect statistics on how you are using `Flicking`. These statistical data do not contain any personal information and are used only as a basis for the development of a user-friendly product.<ko>어떻게 `Flicking`을 사용하고 있는지에 대한 통계 수집 여부를 나타낸다. 이 통계자료는 개인정보를 포함하고 있지 않으며 오직 사용자 친화적인 제품으로 발전시키기 위한 근거자료로서 활용한다.</ko>\n   */\n  constructor(\n    element: string | HTMLElement,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (isString(element)) {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Override moveType option\n    const currentOptions = this.options;\n    const moveType = currentOptions.moveType;\n\n    if (moveType in DEFAULT_MOVE_TYPE_OPTIONS) {\n      currentOptions.moveType = DEFAULT_MOVE_TYPE_OPTIONS[moveType as keyof typeof DEFAULT_MOVE_TYPE_OPTIONS];\n    }\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(this, this.options, this.triggerEvent);\n    this.listenInput();\n    this.listenResize();\n\n    if (this.options.collectStatistics) {\n      sendEvent(\n        \"usage\",\n        \"options\",\n        options,\n      );\n    }\n  }\n\n  /**\n   * Move to the previous panel if it exists.\n   * @ko 이전 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public prev(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      const prevPanel = currentPanel.prev();\n      if (prevPanel) {\n        prevPanel.focus(duration);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the next panel if it exists.\n   * @ko 다음 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation(unit: ms).<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public next(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      const nextPanel = currentPanel.next();\n      if (nextPanel) {\n        nextPanel.focus(duration);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the panel of given index.\n   * @ko 주어진 인덱스에 해당하는 패널로 이동한다.\n   * @param index The index number of the panel to move.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    const state = viewport.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = viewport.getHangerPosition();\n\n    let targetPanel = panel;\n    if (this.options.circular) {\n      const scrollAreaSize = viewport.getScrollAreaSize();\n      // Check all three possible locations, find the nearest position among them.\n      const possiblePositions = [\n        anchorPosition - scrollAreaSize,\n        anchorPosition,\n        anchorPosition + scrollAreaSize,\n      ];\n      const nearestPosition = possiblePositions.reduce((nearest, current) => {\n        return (Math.abs(current - hangerPosition) < Math.abs(nearest - hangerPosition))\n          ? current\n          : nearest;\n      }, Infinity) - panel.getRelativeAnchorPosition();\n\n      const identicals = panel.getIdenticalPanels();\n      const offset = nearestPosition - anchorPosition;\n      if (offset > 0) {\n        // First cloned panel is nearest\n        targetPanel = identicals[1];\n      } else if (offset < 0) {\n        // Last cloned panel is nearest\n        targetPanel = identicals[identicals.length - 1];\n      }\n\n      targetPanel = targetPanel.clone(targetPanel.getCloneIndex(), true);\n      targetPanel.setPosition(nearestPosition);\n    }\n    const currentIndex = this.getIndex();\n\n    if (hangerPosition === targetPanel.getAnchorPosition() && currentIndex === index) {\n      return this;\n    }\n\n    const eventType = panel.getIndex() === viewport.getCurrentIndex()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      targetPanel,\n      viewport.findEstimatedPosition(targetPanel),\n      eventType,\n      null,\n      duration,\n    );\n    return this;\n  }\n\n  /**\n   * Return index of the current panel. `-1` if no panel exists.\n   * @ko 현재 패널의 인덱스 번호를 반환한다. 패널이 하나도 없을 경우 `-1`을 반환한다.\n   * @return Current panel's index, zero-based integer.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getCurrentIndex();\n  }\n\n  /**\n   * Return the wrapper element user provided in constructor.\n   * @ko 사용자가 생성자에서 제공한 래퍼 엘리먼트를 반환한다.\n   * @return Wrapper element user provided.<ko>사용자가 제공한 래퍼 엘리먼트.</ko>\n   */\n  public getElement(): HTMLElement {\n    return this.wrapper;\n  }\n\n  /**\n   * Return current panel. `null` if no panel exists.\n   * @ko 현재 패널을 반환한다. 패널이 하나도 없을 경우 `null`을 반환한다.\n   * @return Current panel.<ko>현재 패널.</ko>\n   */\n  public getCurrentPanel(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel();\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return the panel of given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 패널을 반환한다. 해당 패널이 존재하지 않을 시 `null`이다.\n   * @return Panel of given index.<ko>주어진 인덱스에 해당하는 패널.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return all panels.\n   * @ko 모든 패널들을 반환한다.\n   * @param - Should include cloned panels or not.<ko>복사된 패널들을 포함할지의 여부.</ko>\n   * @return All panels.<ko>모든 패널들.</ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const panels = includeClone\n      ? panelManager.allPanels()\n      : panelManager.originalPanels();\n\n    return panels\n      .filter(panel => !!panel);\n  }\n\n  /**\n   * Return the panels currently shown in viewport area.\n   * @ko 현재 뷰포트 영역에서 보여지고 있는 패널들을 반환한다.\n   * @return Panels currently shown in viewport area.<ko>현재 뷰포트 영역에 보여지는 패널들</ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.viewport.calcVisiblePanels();\n  }\n\n  /**\n   * Return length of original panels.\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.panelManager.getPanelCount();\n  }\n\n  /**\n   * Return how many groups of clones are created.\n   * @ko 몇 개의 클론 그룹이 생성되었는지를 반환한다.\n   * @return Length of cloned panel groups.<ko>클론된 패널 그룹의 개수</ko>\n   */\n  public getCloneCount(): number {\n    return this.viewport.panelManager.getCloneCount();\n  }\n\n  /**\n   * Get maximum panel index for `infinite` mode.\n   * @ko `infinite` 모드에서 적용되는 추가 가능한 패널의 최대 인덱스 값을 반환한다.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return Maximum index of panel that can be added.<ko>최대 추가 가능한 패널의 인덱스.</ko>\n   */\n  public getLastIndex(): number {\n    return this.viewport.panelManager.getLastIndex();\n  }\n\n  /**\n   * Set maximum panel index for `infinite' mode.<br>[needPanel]{@link eg.Flicking#events:needPanel} won't be triggered anymore when last panel's index reaches it.<br>Also, you can't add more panels after it.\n   * @ko `infinite` 모드에서 적용되는 패널의 최대 인덱스를 설정한다.<br>마지막 패널의 인덱스가 설정한 값에 도달할 경우 더 이상 [needPanel]{@link eg.Flicking#events:needPanel} 이벤트가 발생되지 않는다.<br>또한, 설정한 인덱스 이후로 새로운 패널을 추가할 수 없다.\n   * @param - Maximum panel index.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public setLastIndex(index: number): this {\n    this.viewport.setLastIndex(index);\n\n    return this;\n  }\n\n  /**\n   * Return panel movement animation.\n   * @ko 현재 패널 이동 애니메이션이 진행 중인지를 반환한다.\n   * @return Is animating or not.<ko>애니메이션 진행 여부.</ko>\n   */\n  public isPlaying(): boolean {\n    return this.viewport.stateMachine.getState().playing;\n  }\n\n  /**\n   * Unblock input devices.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * Block input devices.\n   * @ko 입력 장치로부터의 입력을 막는다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to [setStatus()]{@link eg.Flicking#setStatus}.\n   * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있다.\n   * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus(): FlickingStatus {\n    const viewport = this.viewport;\n\n    const panels = viewport.panelManager.originalPanels()\n      .filter(panel => !!panel)\n      .map(panel => {\n        return {\n          html: panel.getElement().outerHTML,\n          index: panel.getIndex(),\n        };\n      });\n\n    return {\n      index: viewport.getCurrentIndex(),\n      panels,\n      position: viewport.getCameraPosition(),\n    };\n  }\n\n  /**\n   * Restore to the state of the `status`.\n   * @ko `status`의 상태로 복원한다.\n   * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\n   */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking.\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\n   * @param - The plugin(s) to add.<ko>추가할 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    this.viewport.addPlugins(plugins);\n    return this;\n  }\n\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\n   * @param - The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    this.viewport.removePlugins(plugins);\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(option: Partial<DestroyOption> = {}): void {\n    this.off();\n\n    if (this.options.autoResize) {\n      window.removeEventListener(\"resize\", this.resize);\n    }\n\n    this.viewport.destroy(option);\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * Update panels to current state.\n   * @ko 패널들을 현재 상태에 맞춰 갱신한다.\n   * @method\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public resize = (): this => {\n    const viewport = this.viewport;\n    const options = this.options;\n    const wrapper = this.getElement();\n\n    const allPanels = viewport.panelManager.allPanels();\n    if (!options.isConstantSize) {\n      allPanels.forEach(panel => panel.unCacheBbox());\n    }\n\n    const shouldResetElements = options.renderOnlyVisible\n      && !options.isConstantSize\n      && options.isEqualSize !== true;\n\n    // Temporarily set parent's height to prevent scroll (#333)\n    const parent = wrapper.parentElement!;\n    const origStyle = parent.style.height;\n    parent.style.height = `${parent.offsetHeight}px`;\n\n    viewport.unCacheBbox();\n    // This should be done before adding panels, to lower performance issue\n    viewport.updateBbox();\n\n    if (shouldResetElements) {\n      viewport.appendUncachedPanelElements(allPanels as Panel[]);\n    }\n\n    viewport.resize();\n    parent.style.height = origStyle;\n\n    return this;\n  }\n\n  /**\n   * Add new panels at the beginning of panels.\n   * @ko 제일 앞에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.replace(3, document.createElement(\"div\")); // Add new panel at index 3\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 2\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Prepended at index 0, 1\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 0, pushing every panels behind it.\n   */\n  public prepend(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n\n    const insertingIndex = Math.max(viewport.panelManager.getRange().min - parsedElements.length, 0);\n    return viewport.insert(insertingIndex, parsedElements);\n  }\n\n  /**\n   * Add new panels at the end of panels.\n   * @ko 제일 끝에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.append(document.createElement(\"div\")); // Appended at index 0\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\"); // Appended at index 1\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Appended at index 2, 3\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\"); // Appended at index 4, 5\n   */\n  public append(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n\n    return viewport.insert(viewport.panelManager.getRange().max + 1, element);\n  }\n\n  /**\n   * Replace existing panels with new panels from given index. If target index is empty, add new panel at target index.\n   * @ko 주어진 인덱스로부터의 패널들을 새로운 패널들로 교체한다. 인덱스에 해당하는 자리가 비어있다면, 새로운 패널을 해당 자리에 집어넣는다.\n   * @param index - Start index to replace new panels.<ko>새로운 패널들로 교체할 시작 인덱스</ko>\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of created panels by replace.<ko>교체되어 새롭게 추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   *\n   * // This will add new panel at index 3,\n   * // Index 0, 1, 2 is empty at this moment.\n   * // [empty, empty, empty, PANEL]\n   * flicking.replace(3, document.createElement(\"div\"));\n   *\n   * // As index 2 was empty, this will also add new panel at index 2.\n   * // [empty, empty, PANEL, PANEL]\n   * flicking.replace(2, \"\\<div\\>Panel\\</div\\>\");\n   *\n   * // Index 3 was not empty, so it will replace previous one.\n   * // It will also add new panels at index 4 and 5.\n   * // before - [empty, empty, PANEL, PANEL]\n   * // after - [empty, empty, PANEL, NEW_PANEL, NEW_PANEL, NEW_PANEL]\n   * flicking.replace(3, [\"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\"])\n   */\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.replace(index, element);\n  }\n\n  /**\n   * Remove panel at target index. This will decrease index of panels behind it.\n   * @ko `index`에 해당하는 자리의 패널을 제거한다. 수행시 `index` 이후의 패널들의 인덱스가 감소된다.\n   * @param index - Index of panel to remove.<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] - Number of panels to remove from index.<ko>`index` 이후로 제거할 패널의 개수.</ko>\n   * @return Array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    return this.viewport.remove(index, deleteCount);\n  }\n\n  /**\n   * Get indexes to render. Should be used with `renderOnlyVisible` option.\n   * @private\n   * @ko 렌더링이 필요한 인덱스들을 반환한다. `renderOnlyVisible` 옵션과 함께 사용해야 한다.\n   * @param - Info object of how panel infos are changed.<ko>패널 정보들의 변경 정보를 담는 오브젝트.</ko>\n   * @return Array of indexes to render.<ko>렌더링할 인덱스의 배열</ko>\n   */\n  public getRenderingIndexes(diffResult: DiffResult<any>): number[] {\n    const viewport = this.viewport;\n    const { min, max } = viewport.getVisibleIndex();\n    const maintained = diffResult.maintained.reduce((values: {[key: number]: number}, [before, after]) => {\n      values[before] = after;\n      return values;\n    }, {});\n\n    const prevPanelCount = diffResult.prevList.length;\n    const panelCount = diffResult.list.length;\n    const added = diffResult.added;\n    const list = counter(prevPanelCount * (this.getCloneCount() + 1));\n\n    let visibles = min >= 0\n      ? list.slice(min, max + 1)\n      : list.slice(0, max + 1).concat(list.slice(min));\n    visibles = visibles\n      .filter(val => maintained[val % prevPanelCount] != null)\n      .map(val => {\n        const cloneIndex = Math.floor(val / prevPanelCount);\n        const changedIndex = maintained[val % prevPanelCount];\n\n        return changedIndex + panelCount * cloneIndex;\n      });\n\n    const renderingPanels = [...visibles, ...added];\n    const allPanels = viewport.panelManager.allPanels();\n\n    viewport.setVisiblePanels(renderingPanels.map(index => allPanels[index]));\n\n    return renderingPanels;\n  }\n\n  /**\n   * Synchronize info of panels instance with info given by external rendering.\n   * @ko 외부 렌더링 방식에 의해 입력받은 패널의 정보와 현재 플리킹이 갖는 패널 정보를 동기화한다.\n   * @private\n   * @param - Info object of how panel infos are changed.<ko>패널 정보들의 변경 정보를 담는 오브젝트.</ko>\n   * @param - Whether called from sync method <ko> sync 메소드로부터 호출됐는지 여부 </ko>\n   */\n  public beforeSync(diffInfo: BeforeSyncResult) {\n    const { maintained, added, changed, removed } = diffInfo;\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const isCircular = this.options.circular;\n    const cloneCount = panelManager.getCloneCount();\n    const prevClonedPanels = panelManager.clonedPanels();\n\n    // Update visible panels\n    const newVisiblePanels = viewport.getVisiblePanels()\n      .filter(panel => findIndex(removed, index => {\n        return index === panel.getIndex();\n      }) < 0);\n    viewport.setVisiblePanels(newVisiblePanels);\n\n    // Did not changed at all\n    if (\n      added.length <= 0\n      && removed.length <= 0\n      && changed.length <= 0\n      && cloneCount === prevClonedPanels.length\n    ) {\n      return this;\n    }\n    const prevOriginalPanels = panelManager.originalPanels();\n    const newPanels: Panel[] = [];\n    const newClones: Panel[][] = counter(cloneCount).map(() => []);\n\n    maintained.forEach(([beforeIdx, afterIdx]) => {\n      newPanels[afterIdx] = prevOriginalPanels[beforeIdx];\n      newPanels[afterIdx].setIndex(afterIdx);\n    });\n\n    added.forEach(addIndex => {\n      newPanels[addIndex] = new Panel(null, addIndex, this.viewport);\n    });\n\n    if (isCircular) {\n      counter(cloneCount).forEach(groupIndex => {\n        const prevCloneGroup = prevClonedPanels[groupIndex];\n        const newCloneGroup = newClones[groupIndex];\n\n        maintained.forEach(([beforeIdx, afterIdx]) => {\n          newCloneGroup[afterIdx] = prevCloneGroup\n            ? prevCloneGroup[beforeIdx]\n            : newPanels[afterIdx].clone(groupIndex, false);\n\n          newCloneGroup[afterIdx].setIndex(afterIdx);\n        });\n\n        added.forEach(addIndex => {\n          const newPanel = newPanels[addIndex];\n\n          newCloneGroup[addIndex] = newPanel.clone(groupIndex, false);\n        });\n      });\n    }\n\n    added.forEach(index => { viewport.updateCheckedIndexes({ min: index, max: index }); });\n    removed.forEach(index => { viewport.updateCheckedIndexes({ min: index - 1, max: index + 1 }); });\n\n    const checkedIndexes = viewport.getCheckedIndexes();\n    checkedIndexes.forEach(([min, max], idx) => {\n      // Push checked indexes backward\n      const pushedIndex = added.filter(index => index < min && panelManager.has(index)).length\n        - removed.filter(index => index < min).length;\n      checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n    });\n\n    // Only effective only when there are least one panel which have changed its index\n    if (changed.length > 0) {\n      // Removed checked index by changed ones after pushing\n      maintained.forEach(([, next]) => { viewport.updateCheckedIndexes({ min: next, max: next }); });\n    }\n    panelManager.replacePanels(newPanels, newClones);\n    this.isPanelChangedAtBeforeSync = true;\n  }\n\n  /**\n   * Synchronize info of panels with DOM info given by external rendering.\n   * @ko 외부 렌더링 방식에 의해 입력받은 DOM의 정보와 현재 플리킹이 갖는 패널 정보를 동기화 한다.\n   * @private\n   * @param - Info object of how panel elements are changed.<ko>패널의 DOM 요소들의 변경 정보를 담는 오브젝트.</ko>\n   */\n  public sync(diffInfo: SyncResult): this {\n    const { list, maintained, added, changed, removed } = diffInfo;\n\n    // Did not changed at all\n    if (added.length <= 0 && removed.length <= 0 && changed.length <= 0) {\n      return this;\n    }\n    const viewport = this.viewport;\n    const { renderOnlyVisible, circular } = this.options;\n    const panelManager = viewport.panelManager;\n\n    if (!renderOnlyVisible) {\n      const indexRange = panelManager.getRange();\n      let beforeDiffInfo: BeforeSyncResult = diffInfo;\n\n      if (circular) {\n        const prevOriginalPanelCount = indexRange.max;\n        const originalPanelCount = (list.length / (panelManager.getCloneCount() + 1)) >> 0;\n        const originalAdded = added.filter(index => index < originalPanelCount);\n        const originalRemoved = removed.filter(index => index <= prevOriginalPanelCount);\n        const originalMaintained = maintained.filter(([beforeIdx]) => beforeIdx <= prevOriginalPanelCount);\n        const originalChanged = changed.filter(([beforeIdx]) => beforeIdx <= prevOriginalPanelCount);\n\n        beforeDiffInfo = {\n          added: originalAdded,\n          maintained: originalMaintained,\n          removed: originalRemoved,\n          changed: originalChanged,\n        };\n      }\n      this.beforeSync(beforeDiffInfo);\n    }\n\n    const visiblePanels = renderOnlyVisible\n      ? viewport.getVisiblePanels()\n      : this.getAllPanels(true);\n\n    added.forEach(addedIndex => {\n      const addedElement = list[addedIndex];\n      const beforePanel = visiblePanels[addedIndex] as Panel;\n\n      beforePanel.setElement(addedElement);\n      // As it can be 0\n      beforePanel.unCacheBbox();\n    });\n    if (this.isPanelChangedAtBeforeSync) {\n      viewport.resetVisibleIndex();\n      this.isPanelChangedAtBeforeSync = false;\n    }\n    viewport.resize();\n\n    return this;\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const viewport = flicking.viewport;\n    const stateMachine = viewport.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: viewport.stopCamera,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", this.resize);\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: string,\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n\n    let canceled: boolean = true;\n\n    // Ignore events before viewport is initialized\n    if (viewport) {\n      const state = viewport.stateMachine.getState();\n      const { prev, next } = viewport.getScrollArea();\n      const pos = viewport.getCameraPosition();\n      let progress = getProgress(pos, [prev, prev, next]);\n\n      if (this.options.circular) {\n        progress %= 1;\n      }\n      canceled = !super.trigger(eventName, merge({\n        type: eventName,\n        index: this.getIndex(),\n        panel: this.getCurrentPanel(),\n        direction: state.direction,\n        holding: state.holding,\n        progress,\n        axesEvent,\n        isTrusted,\n      }, params));\n    }\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = viewport.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n    const previousPosition = viewport.getCameraPosition();\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNextDirection = inputOffset < 0;\n\n      let cameraChange = pos - previousPosition;\n      const looped = isNextDirection === (pos < previousPosition);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = (cameraChange > 0 ? -1 : 1) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.direction = currentDirection;\n    }\n    state.delta += axesEvent.delta.flick;\n\n    viewport.moveCamera(pos, axesEvent);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted)\n      .onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition, axesEvent);\n      });\n  }\n}\n\nexport default Flicking;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Flicking from \"./Flicking\";\nimport Viewport from \"./components/Viewport\";\nimport StateMachine from \"./components/StateMachine\";\nimport Panel from \"./components/Panel\";\nimport Component from \"@egjs/component\";\nimport State from \"./states/State\";\nimport { DiffResult } from \"@egjs/list-differ\";\n\nexport type ValueOf<T> = T[keyof T];\n/**\n * HTML `string` of single/mutiple HTMLElement, or an instance of `HTMLElement`.\n * @ko 단일/복수의 HTMLElement의 outerHTML에 해당하는 `string`, 혹은 `HTMLElement`의 인스턴스.\n * @typedef\n * @memberof eg.Flicking\n */\nexport type ElementLike = string | HTMLElement;\n\n/**\n * @typedef\n * @memberof eg.Flicking\n * @property - A prefix of class names will be added for the panels, viewport, and camera.<ko>패널들과 뷰포트, 카메라에 추가될 클래스 이름의 접두사.</ko>\n * @property - Deceleration value for panel movement animation for animation triggered by manual user input. A higher value means a shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n * @property - The direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n * @property - Enables circular mode, which connects first/last panel for continuous scrolling.<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능하다.</ko>\n * @property - Enables infinite mode, which can automatically trigger needPanel until reaching the last panel's index reaches the lastIndex.<ko>무한 모드를 활성화한다. 무한 모드에서는 needPanel 이벤트를 자동으로 트리거한다. 해당 동작은 마지막 패널의 인덱스가 lastIndex와 일치할때까지 일어난다.</ko>\n * @property - A Threshold from viewport edge before triggering `needPanel` event in infinite mode.<ko>무한 모드에서 `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리.</ko>\n * @property - Maximum panel index that Flicking can set. Flicking won't trigger `needPanel` when the event's panel index is greater than it.<br/>Also, if the last panel's index reached a given index, you can't add more panels.<ko>Flicking이 설정 가능한 패널의 최대 인덱스. `needPanel` 이벤트에 지정된 인덱스가 최대 패널의 개수보다 같거나 커야 하는 경우에 이벤트를 트리거하지 않게 한다.<br>또한, 마지막 패널의 인덱스가 주어진 인덱스와 동일할 경우, 새로운 패널을 더 이상 추가할 수 없다.</ko>\n * @property - Movement threshold to change panel(unit: pixel). It should be dragged above the threshold to change the current panel.<ko>패널 변경을 위한 이동 임계값 (단위: 픽셀). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.</ko>\n * @property - Duration of the panel movement animation. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n * @property - An easing function applied to the panel movement animation. Default value is `easeOutCubic`.<ko>패널 이동 애니메이션에 적용할 easing함수. 기본값은 `easeOutCubic`이다.</ko>\n * @property - Index of the panel to set as default when initializing. A zero-based integer.<ko>초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n * @property - Types of input devices to enable.({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Reference})<ko>활성화할 입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 참고})</ko>\n * @property - The threshold angle value(0 ~ 90).<br>If the input angle from click/touched position is above or below this value in horizontal and vertical mode each, scrolling won't happen.<ko>스크롤 동작을 막기 위한 임계각(0 ~ 90).<br>클릭/터치한 지점으로부터 계산된 사용자 입력의 각도가 horizontal/vertical 모드에서 각각 크거나 작으면, 스크롤 동작이 이루어지지 않는다.</ko>\n * @property - The size value of the bounce area. Only can be enabled when `circular=false`.<br>You can set different bounce value for prev/next direction by using array.<br>`number` for px value, and `string` for px, and % value relative to viewport size.(ex - 0, \"10px\", \"20%\")<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.<br>배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정 가능하다.<br>`number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있다.(ex - 0, \"10px\", \"20%\")</ko>\n * @property - Whether the `resize` method should be called automatically after a window resize event.<ko>window의 `resize` 이벤트 이후 자동으로 resize()메소드를 호출할지의 여부.</ko>\n * @property - Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n * @property - z-index value for viewport element.<ko>뷰포트 엘리먼트의 z-index 값.</ko>\n * @property - Prevent the view from going out of the first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n * @property - Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n * @property - The reference position of the hanger in the viewport, which hangs panel anchors should be stopped at.<br>It should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign.<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n * @property - The reference position of the anchor in panels, which can be hanged by viewport hanger.<br>It should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign.<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n * @property - Space value between panels. Should be given in number.(px)<ko>패널간에 부여할 간격의 크기를 나타내는 숫자.(px)</ko>\n * @property - Movement style by user input. (ex: snap, freeScroll)<ko>사용자 입력에 의한 이동 방식.(ex: snap, freeScroll)</ko>\n * @property - Whether to use `offsetWidth`/`offsetHeight` instead of `getBoundingClientRect` for panel/viewport size calculation.<br/>You can use this option to calculate the original panel size when CSS transform is applied to viewport or panel.<br/>⚠️ If panel size is not fixed integer value, there can be a 1px gap between panels.<ko>패널과 뷰포트의 크기를 계산할 때 `offsetWidth`/`offsetHeight`를 `getBoundingClientRect` 대신 사용할지 여부.<br/>패널이나 뷰포트에 CSS transform이 설정되어 있을 때 원래 패널 크기를 계산하려면 활성화할 수 있다.<br/>⚠️ 패널의 크기가 정수로 고정되어있지 않다면 패널 사이에 1px의 공간이 생길 수 있다.</ko>\n * @property - This option indicates whether all panels have the same size(true) of first panel, or it can hold a list of class names that determines panel size.<br/>Enabling this option can increase performance while recalculating panel size.<ko>모든 패널의 크기가 동일한지(true), 혹은 패널 크기를 결정하는 패널 클래스들의 리스트.<br/>이 옵션을 설정하면 패널 크기 재설정시에 성능을 높일 수 있다.</ko>\n * @property - Whether all panels have a constant size that won't be changed after resize. Enabling this option can increase performance while recalculating panel size.<ko>모든 패널의 크기가 불변인지의 여부. 이 옵션을 'true'로 설정하면 패널 크기 재설정시에 성능을 높일 수 있다.</ko>\n * @property - Whether to render visible panels only. This can dramatically increase performance when there're many panels.<ko>보이는 패널만 렌더링할지 여부를 설정한다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있다.</ko>\n * @property - Whether to use external rendering. It will delegate DOM manipulation and can synchronize the rendered state by calling `sync()` method. You can use this option to use in frameworks like React, Vue, Angular, which has its states and rendering methods.<ko>외부 렌더링을 사용할 지의 여부. 이 옵션을 사용시 렌더링을 외부에 위임할 수 있고, `sync()`를 호출하여 그 상태를 동기화할 수 있다. 이 옵션을 사용하여, React, Vue, Angular 등 자체적인 상태와 렌더링 방법을 갖는 프레임워크에 대응할 수 있다.</ko>\n * @property - Whether to collect statistics on how you are using `Flicking`. These statistical data do not contain any personal information and are used only as a basis for the development of a user-friendly product.<ko>어떻게 `Flicking`을 사용하고 있는지에 대한 통계 수집 여부를 나타낸다. 이 통계자료는 개인정보를 포함하고 있지 않으며 오직 사용자 친화적인 제품으로 발전시키기 위한 근거자료로서 활용한다.</ko>\n */\nexport interface FlickingOptions {\n  classPrefix: string;\n  deceleration: number;\n  horizontal: boolean;\n  circular: boolean;\n  infinite: boolean;\n  infiniteThreshold: number | string;\n  lastIndex: number;\n  threshold: number;\n  duration: number;\n  panelEffect: (x: number) => number;\n  defaultIndex: number;\n  inputType: string[];\n  thresholdAngle: number;\n  bounce: number | string | [number | string, number | string];\n  autoResize: boolean;\n  adaptive: boolean;\n  zIndex: number | \"\";\n  bound: boolean;\n  overflow: boolean;\n  hanger: number | string;\n  anchor: number | string;\n  gap: number;\n  moveType: MoveTypeOption;\n  useOffset: boolean;\n  isEqualSize: boolean | string[];\n  isConstantSize: boolean;\n  renderOnlyVisible: boolean;\n  renderExternal: boolean;\n  collectStatistics: boolean;\n}\n\nexport type MoveTypeObjectOption = MoveTypeSnapOption | MoveTypeFreeScrollOption;\nexport type MoveTypeStringOption = MoveTypeObjectOption[\"type\"];\n\nexport interface MoveTypeContext {\n  viewport: Viewport;\n  axesEvent: {\n    delta: { flick: number };\n    depaPos: { flick: number };\n    destPos: { flick: number };\n    duration: number;\n  };\n  state: State;\n  swipeDistance: number;\n  isNextDirection: boolean;\n}\n\nexport interface DestinationInfo {\n  panel: Panel;\n  destPos: number;\n  duration: number;\n  eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | \"\";\n}\n\n/**\n * Movement style by user input.\n * @ko 사용자 입력에 의한 이동 방식.\n * @typedef {\"snap\" | \"freeScroll\" | eg.Flicking.MoveTypeSnapOption | eg.Flicking.MoveTypeFreeScrollOption}\n * @memberof eg.Flicking\n */\nexport type MoveTypeOption = MoveTypeStringOption | MoveTypeObjectOption;\n\n/**\n * With \"snap\" move type, momentum is applied while choosing destination panel at release time.<br>You can set how many panels can go after relase.\n * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식.<br>입력 중단 이후 최대 몇 개까지의 패널을 통과하여 이동할지 설정할 수 있다.\n * @typedef\n * @memberof eg.Flicking\n * @property - Should be `\"snap\"` to enable snap mode.<ko>`\"snap\"`을 지정하여 snap 모드를 활성화할 수 있다.</ko>\n * @property {number} [count=1] - Maximum number of panels can go after release.<ko>입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수.</ko>\n */\nexport interface MoveTypeSnapOption {\n  type: \"snap\";\n  count: number;\n}\n\n/**\n * With \"freeScroll\" move type, it can be scrolled freely without alignment.\n * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식.\n * @typedef\n * @memberof eg.Flicking\n * @property - Should be `\"freeScroll\"` to enable free scroll mode.<ko>`\"freeScroll\"`을 지정하여 free scroll 모드를 활성화할 수 있다.</ko>\n */\nexport interface MoveTypeFreeScrollOption {\n  type: \"freeScroll\";\n}\n\n// State interface to save instance\n/**\n * @typedef\n * @memberof eg.Flicking\n * @property - Index of current panel.<ko>현재 패널의 인덱스.</ko>\n * @property panels - Panels Flicking has.<ko>Flicking이 갖고 있는 패널들의 정보.</ko>\n * @property {string} [panels.html] - `outerHTML` of each panel elements.<ko>각 패널 엘리먼트의 `outerHTML`.</ko>\n * @property {index} [panels.index] - Index of each panels.<ko>각 패널의 인덱스.</ko>\n * @property - Camera position of Flicking.<ko>Flicking의 카메라 위치.</ko>\n */\nexport interface FlickingStatus {\n  index: number;\n  panels: Array<{\n    html: string;\n    index: number;\n  }>;\n  position: number;\n}\n\nexport interface OriginalStyle {\n  className: string | null;\n  style: string | null;\n}\n\n/**\n * @typedef\n * @memberof eg.Flicking\n * @property - HTML element of panel object.<ko>패널 오브젝트에 지정된 HTML Element.</ko>\n * @property - Index of panel, zero-based integer.<ko>패널의 인덱스로, 0부터 시작하는 정수.</ko>\n * @property - Position of panel where it is placed from left(horizontal)/top(vertical).<ko>패널의 위치로, 왼쪽(horizontal)/위(vertical)을 기준으로 얼마나 떨어져 있는지를 나타내는 값.</ko>\n * @property - Position of panel anchor where it is actually stopped interacting with hanger position.<ko>Hanger와 상호작용하여 패널에 도착했을 때의 위치를 계산하는데 사용되는 패널 내부 Anchor의 위치.</ko>\n * @property - Size of panel, width(horizontal)/height(vertical) in `px`.<ko>`px`단위의 패널의 크기, horizontal일 때는 너비, vertical일 때는 높이에 해당한다.</ko>\n * @property - Progress of movement between previous or next panel relative to current panel.<ko> 현재 패널로부터 이전/다음 패널으로의 이동 진행률.</ko>\n * @property - Progress of movement between points that panel is completely invisible outside of viewport.(prev direction: -1, selected point: 0, next direction: 1) <ko>현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도.(prev방향: -1, 선택 지점: 0, next방향: 1)</ko>\n * @property - Percentage of area where panel is visible in the viewport.<ko>뷰포트 안에서 패널이 보이는 영역의 비율.</ko>\n * @property focus - Move to this panel.<ko>이 패널로 이동한다.</ko>\n * @property {number} [focus.duration] Duration of the panel movement. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n * @property update - Update panel element with given function.<ko>패널 요소를 주어진 함수를 이용하여 업데이트한다.</ko>\n * @property {function} [update.updateFunction] Callback function to update panel element. argument is panel's element.<ko>패널 요소를 업데이트하기 위한 콜백 함수. 패널의 HTMLElement를 인자로 갖는다.</ko>\n * @property - Return previous panel of current panel, `null` if it doesn't exist.<ko>현재 패널의 이전 패널을 반환한다. 패널이 존재하지 않을 시 `null`을 반환한다.</ko>\n * @property - Return next panel of current panel, `null` if it doesn't exist.<ko>현재 패널의 다음 패널을 반환한다. 패널이 존재하지 않을 시 `null`을 반환한다.</ko>\n * @property - Insert new panels before reference panel. Return inserted panels.<ko>새로운 패널들을 해당 패널 앞에 추가한다. 새로 추가된 패널들을 반환한다.</ko>\n * @property - Insert new panels after reference panel. Return inserted panels.<ko>새로운 패널들을 해당 패널 뒤에 추가한다. 새로 추가된 패널들을 반환한다.</ko>\n * @property - Remove this panel.<ko>이 패널을 제거한다.</ko>\n * @example\n * - **Updating panel**\n * ```javascript\n * // As panel elements can be cloned in circular mode, `element` parameter is provided as read-only.\n * // You should use `update()` function to consistently update all panel elements cloned.\n *\n * // Don't\n * panel.element.classList.add(\"foo\");\n * // Do\n * panel.update(el => {\n *   el.classList.add(\"foo\");\n * });\n * ```\n */\n\nexport interface FlickingPanel {\n  getElement: () => HTMLElement;\n  getIndex: () => number;\n  getPosition: () => number;\n  getAnchorPosition: () => number;\n  getSize: () => number;\n  getProgress: () => number;\n  getOutsetProgress: () => number;\n  getVisibleRatio: () => number;\n  focus: (duration?: number) => void;\n  update: (updateFunction: (element: HTMLElement) => any) => void;\n  prev: () => FlickingPanel | null;\n  next: () => FlickingPanel | null;\n  insertBefore: (element: ElementLike | ElementLike[]) => FlickingPanel[];\n  insertAfter: (element: ElementLike | ElementLike[]) => FlickingPanel[];\n  remove: () => void;\n}\n\nexport interface Direction {\n  readonly PREV: \"PREV\";\n  readonly NEXT: \"NEXT\";\n}\n\n/**\n * Event triggered when user started dragging.\n * @ko 사용자가 드래그를 시작했을 떄 발생하는 이벤트\n * @event eg.Flicking#holdStart\n * @type eg.Flicking.FlickingEvent\n */\n\n/**\n * Event triggered when user stopped dragging.\n * @ko 사용자가 드래그를 중단했을 때 발생하는 이벤트.\n * @event eg.Flicking#holdEnd\n * @type eg.Flicking.FlickingEvent\n */\n\n/**\n * Event triggered once before first [move]{@link eg.Flicking#event:move} event.\n * @ko 첫 번째 [move]{@link eg.Flicking#event:move}이벤트 직전에 단 한번 발생하는 이벤트.\n * @event eg.Flicking#moveStart\n * @type eg.Flicking.FlickingEvent\n */\n\n/**\n * Event triggered while moving to the destination panel.\n * @ko 목적 패널로의 이동 도중에 발생하는 이벤트.\n * @event eg.Flicking#move\n * @type eg.Flicking.FlickingEvent\n */\n\n/**\n * Event triggered after finish moving to the destination panel.\n * @ko 목적 패널로의 이동을 완료한 다음 발생하는 이벤트.\n * @event eg.Flicking#moveEnd\n * @type eg.Flicking.FlickingEvent\n */\n\n/**\n * Event that indicates index will be changed, and isn't restoring. Index will be changed at `moveEnd` event.<br>It can be triggered when user finished input, or flicking start to mvoe by method.<br>It won't be triggered when moving to same panel, unless it's circulated more than one cycle in circular mode.<br>Calling `stop()` in event will prevent index changing & panel moving.<br><br>`event` doesn't have `axesEvent` property when triggered by [moveTo()]{@link eg.Flicking#moveTo}, [prev()]{@link eg.Flicking#prev}, [next()]{@link eg.Flicking#next} method.\n * @ko `restore`되지 않고, 인덱스가 변경될 것임을 나타내는 이벤트. 실제 인덱스는 `moveEnd` 이벤트에서 변경된다.<br>사용자가 입력을 마쳤을 때, 혹은 메소드를 통해 이동을 시작했을 때 발생한다.<br>동일 패널로 이동시에는 발생되지 않지만, circular 모드에서 한 바퀴 이상 순환하여 동일 패널로 도착했을 때에도 발생된다.<br>이벤트의 `stop()`을 호출시 패널로의 이동을 막는다.<br><br>[moveTo()]{@link eg.Flicking#moveTo}, [prev()]{@link eg.Flicking#prev}, [next()]{@link eg.Flicking#next}와 같은 메소드에 의해 호출되었을 경우 `event`내의 `axesEvent` 프로퍼티 값은 undefined이다.\n * @event eg.Flicking#change\n * @type eg.Flicking.ChangeEvent\n */\n\n/**\n * Event triggered when user drag amount not reached `threshold` in [FlickingOptions]{@link eg.Flicking.FlickingOptions}.\n * @ko 사용자가 드래그한 정도가 [FlickingOptions]{@link eg.Flicking.FlickingOptions}의 `threshold`값보다 작을 때 발생하는 이벤트.\n * @event eg.Flicking#restore\n * @type eg.Flicking.FlickingEvent\n */\n\n/**\n * Event triggered when user statically selected(clicked) panel.\n * @ko 사용자가 패널을 정적으로 선택(클릭)했을 때 발생하는 이벤트.\n * @event eg.Flicking#select\n * @type eg.Flicking.SelectEvent\n */\n\n /**\n  * Event triggered when Flicking confronts panels don't have successive indexes, so it need more content to draw panel in infinite mode.\n  * @ko 무한 모드에서, Flicking이 인덱스가 연속하지 않은 패널들을 만나 새로운 패널이 필요함을 알리고자 할 때 발생시키는 이벤트.\n  * @event eg.Flicking#needPanel\n  * @type eg.Flicking.NeedPanelEvent\n  */\n\n/**\n * Event triggered when Flicking's visible panel changes. This event only triggered with `renderOnlyVisible` option.\n * @ko 보이는 패널 정보에 변화가 있을 경우에 발생되는 이벤트. `renderOnlyVisible` 옵션이 활성화된 경우에만 트리거된다.\n * @event eg.Flicking#visibleChange\n * @type eg.Flicking.VisibleChangeEvent\n */\n\nexport interface EventType {\n  readonly HOLD_START: \"holdStart\";\n  readonly HOLD_END: \"holdEnd\";\n  readonly MOVE_START: \"moveStart\";\n  readonly MOVE: \"move\";\n  readonly MOVE_END: \"moveEnd\";\n  readonly CHANGE: \"change\";\n  readonly RESTORE: \"restore\";\n  readonly SELECT: \"select\";\n  readonly NEED_PANEL: \"needPanel\";\n  readonly VISIBLE_CHANGE: \"visibleChange\";\n}\n\n/**\n * @typedef\n * @memberof eg.Flicking\n * @property - Name of the event.<ko>이벤트명</ko>\n * @property - Index number of the current panel.<ko>현재 패널의 인덱스 번호.</ko>\n * @property - Current panel.<ko> 현재 패널.</ko>\n * @property - Absolute progress of how much it proceed from first panel. 0 at first panel, and 1 at last panel.<ko>첫 번째 패널로부터 얼마만큼 진행했는지를 나타내는 진행도. 첫번째 패널에서 0, 마지막 패널에서 1의 값을 갖는다.</ko>\n * @property - `true` when the event was generated by a user action(\"mouse\" or \"touch\") otherwise `false`.<ko>사용자 액션(\"mouse\" 또는 \"touch\")에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`.</ko>\n * @property - Whether the user is inputting through the input device. (Whether it is 'mousedown' for a mouse device or 'touchmove' for a touch device.)<ko>사용자가 입력 장치를 통해 입력중인지 여부. (마우스 장치라면 'mousedown' 여부, 터치 장치라면 'touchmove' 여부)</ko>\n * @property - Cancel the default action, and prevents every events after it.<br>Not effective with events postfixed with `-End`<ko>이벤트의 기본동작을 취소하고, 해당 이벤트 뒤에 발생할 이벤트들을 전부 발생하지 않도록 한다.<br>`-End`가 접미사로 붙은 이벤트에서는 유효한 동작을 하지 않는다.</ko>\n * @property - Direction of the panel movement. `null` if not moved at all.<ko>패널 이동 방향. 아직 움직이지 않았을 경우 `null`이다.</ko>\n * @property - Original event emitted from {@link https://naver.github.io/egjs-axes/release/latest/doc/ Axes} instance.<ko>내부의 {@link https://naver.github.io/egjs-axes/release/latest/doc Axes} 인스턴스로부터 발생된 원본 이벤트.</ko>\n * @property - Flicking instance that triggered event.<ko>이벤트를 발생시킨 Flicking의 인스턴스</ko>\n */\nexport interface FlickingEvent {\n  type: string;\n  index: number;\n  panel: FlickingPanel | null;\n  progress: number;\n  isTrusted: boolean;\n  holding: boolean;\n  stop: () => void;\n  direction: ValueOf<Direction> | null;\n  axesEvent?: any;\n  currentTarget: Flicking;\n}\n\n/**\n * Event that indicates index will be changed, and isn't restoring. Index will be changed at `moveEnd` event.\n * @ko `restore`되지 않고, 인덱스가 변경될 것임을 나타내는 이벤트. 실제 인덱스는 `moveEnd`이벤트에서 변경된다.\n * @typedef\n * @memberof eg.Flicking\n * @property - Name of the event.<ko>이벤트명</ko>\n * @property - Expected panel's index that will arrive at animation end.<ko>애니메이션 종료 시점에 도착할 것으로 예측되는 패널의 인덱스.</ko>\n * @property - Expected panel that will arrive at animation end.<ko>애니메이션 종료 시점에 도착할 것으로 예측되는 패널.</ko>\n * @property - Absolute progress of how much it proceed from first panel. 0 at first panel, and 1 at last panel.<ko>첫 번째 패널로부터 얼마만큼 진행했는지를 나타내는 진행도. 첫번째 패널에서 0, 마지막 패널에서 1의 값을 갖는다.</ko>\n * @property - `true` when the event was generated by a user action(\"mouse\" or \"touch\") otherwise `false`.<ko>사용자 액션(\"mouse\" 또는 \"touch\")에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`.</ko>\n * @property - Whether the user is inputting through the input device. (Whether it is 'mousedown' for a mouse device or 'touchmove' for a touch device.)<ko>사용자가 입력 장치를 통해 입력중인지 여부. (마우스 장치라면 'mousedown' 여부, 터치 장치라면 'touchmove' 여부)</ko>\n * @property - Cancel the default action, and prevents every events after it.<br>Not effective with events postfixed with `-End`<ko>이벤트의 기본동작을 취소하고, 해당 이벤트 뒤에 발생할 이벤트들을 전부 발생하지 않도록 한다.<br>`-End`가 접미사로 붙은 이벤트에서는 유효한 동작을 하지 않는다.</ko>\n * @property - Expected direction of the panel movement.<ko>예측되는 패널 이동 방향.</ko>\n * @property - Original event emitted from {@link https://naver.github.io/egjs-axes/release/latest/doc/ Axes} instance.<br/>Is undefined when when triggered by [moveTo()]{@link eg.Flicking#moveTo}, [prev()]{@link eg.Flicking#prev}, [next()]{@link eg.Flicking#next}.<ko>내부의 {@link https://naver.github.io/egjs-axes/release/latest/doc Axes} 인스턴스로부터 발생된 원본 이벤트.<br/>[moveTo()]{@link eg.Flicking#moveTo}, [prev()]{@link eg.Flicking#prev}, [next()]{@link eg.Flicking#next}와 같은 메소드에 의해 발생되었을 경우 undefined.</ko>\n * @property - Flicking instance that triggered event.<ko>이벤트를 발생시킨 Flicking의 인스턴스</ko>\n */\nexport interface ChangeEvent {\n  type: string;\n  index: number;\n  panel: FlickingPanel | null;\n  progress: number;\n  isTrusted: boolean;\n  holding: boolean;\n  stop: () => void;\n  direction: ValueOf<Direction> | null;\n  axesEvent?: any;\n  currentTarget: Flicking;\n}\n\n/**\n * Event will be triggered when panel is statically click / touched.\n * @ko 패널이 정적으로 클릭(혹은 터치)되었을 때 발생되는 이벤트.\n * @typedef\n * @memberof eg.Flicking\n * @property - Name of the event.<ko>이벤트명</ko>\n * @property - Selected panel's index.<ko>선택된 패널의 인덱스.</ko>.\n * @property - Selected panel.<ko>선택된 패널.</ko>.\n * @property - Absolute progress of how much it proceed from first panel. 0 at first panel, and 1 at last panel.<ko>첫 번째 패널로부터 얼마만큼 진행했는지를 나타내는 진행도. 첫번째 패널에서 0, 마지막 패널에서 1의 값을 갖는다.</ko>\n * @property - `true` when the event was generated by a user action(\"mouse\" or \"touch\") otherwise `false`.<ko>사용자 액션(\"mouse\" 또는 \"touch\")에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`.</ko>\n * @property - Whether the user is inputting through the input device. (Whether it is 'mousedown' for a mouse device or 'touchmove' for a touch device.)<ko>사용자가 입력 장치를 통해 입력중인지 여부. (마우스 장치라면 'mousedown' 여부, 터치 장치라면 'touchmove' 여부)</ko>\n * @property - Expected direction of the panel movement.<ko>예측되는 패널 이동 방향.</ko>\n * @property - Original event emitted from {@link https://naver.github.io/egjs-axes/release/latest/doc/ Axes} instance.<ko>내부의 {@link https://naver.github.io/egjs-axes/release/latest/doc Axes} 인스턴스로부터 발생된 원본 이벤트.</ko>\n * @property - Flicking instance that triggered event.<ko>이벤트를 발생시킨 Flicking의 인스턴스</ko>\n */\nexport interface SelectEvent {\n  type: string;\n  index: number;\n  panel: FlickingPanel | null;\n  progress: number;\n  isTrusted: boolean;\n  holding: boolean;\n  direction: ValueOf<Direction> | null;\n  axesEvent?: any;\n  currentTarget: Flicking;\n}\n\n/**\n * Event can be triggered in infinite mode. When camera element reaches at infinite threshold, this event can be triggered to indicate there should be more content to be displayed.\n * @ko 무한 모드에서 발생될 수 있는 이벤트. 화면의 양 끝, 혹은 불연속적인 인덱스를 가진 패널을 기준으로 `infiniteThreshold`만큼 떨어진 지점에 도달하였을 때 발생될 수 있다.\n * @typedef\n * @memberof eg.Flicking\n * @property - Name of the event.<ko>이벤트명</ko>\n * @property - Index of panel that needs panel before or after.<ko>앞 또는 뒤에 패널이 필요한 패널의 인덱스.</ko>.\n * @property - Reference panel that needs panel before or after it.<ko>앞 또는 뒤에 패널이 필요한 기준 패널.</ko>.\n * @property - Absolute progress of how much it proceed from first panel. 0 at first panel, and 1 at last panel.<ko>첫 번째 패널로부터 얼마만큼 진행했는지를 나타내는 진행도. 첫번째 패널에서 0, 마지막 패널에서 1의 값을 갖는다.</ko>\n * @property - `true` when the event was generated by a user action(\"mouse\" or \"touch\") otherwise `false`.<ko>사용자 액션(\"mouse\" 또는 \"touch\")에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`.</ko>\n * @property - Whether the user is inputting through the input device. (Whether it is 'mousedown' for a mouse device or 'touchmove' for a touch device.)<ko>사용자가 입력 장치를 통해 입력중인지 여부. (마우스 장치라면 'mousedown' 여부, 터치 장치라면 'touchmove' 여부)</ko>\n * @property - Direction of panel is needed from reference panel. `null` if no panel exists.<ko>기준 패널로부터 패널이 필요한 방향. 패널이 하나도 없을 경우 `null`이다.</ko>\n * @property - Original event emitted from {@link https://naver.github.io/egjs-axes/release/latest/doc/ Axes} instance.<ko>내부의 {@link https://naver.github.io/egjs-axes/release/latest/doc Axes} 인스턴스로부터 발생된 원본 이벤트.</ko>\n * @property - Flicking instance that triggered event.<ko>이벤트를 발생시킨 Flicking의 인스턴스</ko>\n * @property - A helper function that can be used to fill the empty panel area without consideration of direction.<ko>방향을 고려하지 않고 패널을 손쉽게 추가할 수 있게 해주는 헬퍼 함수.</ko>\n * @property range - Range of indexes that is emtpy.<ko>패널이 존재하지 않는 인덱스의 범위.</ko>\n * @property {number} [range.min] - Minimum index of panels needed.<ko>필요한 패널들의 최소 인덱스.</ko>.\n * @property {number} [range.max] - Maximum index of panels needed.<ko>필요한 패널들의 최대 인덱스.</ko>.\n * @property {number} [range.length] - How many panels are needed to fill empty spaces.<ko>몇 개의 패널이 필요한지를 나타내는 정수.</ko>\n * @example\n * ```js\n * flicking.on(\"needPanel\", e => {\n *     // You can use \"fill\" method in event to add panels easily.\n *     e.fill(\"<div>New panel</div>\");\n * })\n * ```\n */\nexport interface NeedPanelEvent {\n  type: string;\n  index: number;\n  panel: FlickingPanel | null;\n  progress: number;\n  isTrusted: boolean;\n  holding: boolean;\n  direction: ValueOf<Direction> | null;\n  axesEvent?: any;\n  currentTarget: Flicking;\n  fill: (elements: ElementLike | ElementLike[]) => FlickingPanel[];\n  range: {\n    min: number;\n    max: number;\n    length: number;\n  };\n}\n\n/**\n * Event triggered when Flicking's visible panel changes. This event only triggered with `renderOnlyVisible` option.\n * @ko 보이는 패널 정보에 변화가 있을 경우에 발생되는 이벤트. `renderOnlyVisible` 옵션이 활성화된 경우에만 트리거된다.\n * @typedef\n * @memberof eg.Flicking\n * @property - Name of the event.<ko>이벤트명</ko>\n * @property range - Range of indexes that is newly visible.<ko>새로 보이는 패널의 인덱스 범위.</ko>\n * @property {number} [range.min] - Minimum index of visible panels.<ko>보이는 패널들 중 최소 인덱스.</ko>.\n * @property {number} [range.max] - Maximum index of visible panels.<ko>필요한 패널들 중 최대 인덱스.</ko>.\n */\nexport interface VisibleChangeEvent {\n  type: string;\n  range: {\n    min: number;\n    max: number;\n  };\n}\n\nexport interface StateType {\n  readonly IDLE: 0;\n  readonly HOLDING: 1;\n  readonly DRAGGING: 2;\n  readonly ANIMATING: 3;\n  readonly DISABLED: 4;\n}\n\nexport interface AxesEventType {\n  readonly HOLD: \"hold\";\n  readonly CHANGE: \"change\";\n  readonly RELEASE: \"release\";\n  readonly ANIMATION_END: \"animationEnd\";\n  readonly FINISH: \"finish\";\n}\n\nexport interface TriggerCallback {\n  onSuccess(callback: () => any): TriggerCallback;\n  onStopped(callback: () => any): TriggerCallback;\n}\n\nexport interface FlickingContext {\n  flicking: Flicking;\n  viewport: Viewport;\n  transitTo: StateMachine[\"transitTo\"];\n  triggerEvent: Flicking[\"triggerEvent\"];\n  moveCamera: Flicking[\"moveCamera\"];\n  stopCamera: Viewport[\"stopCamera\"];\n}\n\nexport interface BoundingBox {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\n/**\n * @typedef\n * @memberof eg.Flicking\n * @property - Method called when plugin is added.<ko>플러그인을 추가했을 때 발생하는 메소드.</ko>\n * @property - Method called when `resize` or `update` in flicking.<ko>플리킹에서 `resize`가 발생하거나 `update`를 했을 때 발생하는 메소드.</ko>\n * @property - Method called when plugin is removed.<ko>플러그인을 제거했을 때 발생하는 메소드.</ko>\n */\nexport interface Plugin {\n  init(flicking: Flicking): void;\n  update?(flicking: Flicking): void;\n  destroy(flicking: Flicking): void;\n}\n\nexport type ExcludeKeys = keyof Component\n  | \"replace\" | \"append\" | \"remove\" | \"prepend\"\n  | \"beforeSync\" | \"sync\" | \"getCloneCount\" | \"getRenderingIndexes\"\n  | \"getLastIndex\" | \"setLastIndex\" | \"addPlugins\" | \"removePlugins\";\nexport type FlickingMethodsKeys = Exclude<keyof Flicking, ExcludeKeys>;\nexport type FlickingMethods = Pick<Flicking, FlickingMethodsKeys>;\n\nexport interface DestroyOption {\n  preserveUI: boolean;\n}\n\nexport type BeforeSyncResult = Pick<DiffResult<any>, \"added\" | \"changed\" | \"maintained\" | \"removed\">;\nexport type SyncResult = Pick<DiffResult<HTMLElement>, \"added\" | \"changed\" | \"maintained\" | \"removed\" | \"list\">;\n"],"names":["MOVE_TYPE","SNAP","FREE_SCROLL","DEFAULT_MOVE_TYPE_OPTIONS","snap","type","count","freeScroll","isBrowser","document","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","infinite","infiniteThreshold","lastIndex","Infinity","threshold","duration","panelEffect","x","Math","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","moveType","useOffset","isEqualSize","isConstantSize","renderOnlyVisible","renderExternal","collectStatistics","DEFAULT_VIEWPORT_CSS","position","DEFAULT_CAMERA_CSS","width","height","willChange","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NEED_PANEL","VISIBLE_CHANGE","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","IDLE","HOLDING","DRAGGING","ANIMATING","DISABLED","DIRECTION","PREV","NEXT","FLICKING_METHODS","prev","next","moveTo","getIndex","getAllPanels","getCurrentPanel","getElement","getPanel","getPanelCount","getStatus","getVisiblePanels","enableInput","disableInput","destroy","resize","setStatus","isPlaying","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","name","has3d","supportedStyle","documentElement","style","transformName","prefixedTransform","Error","el","createElement","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","length","TRANSFORM","target","_i","srcs","forEach","source","Object","keys","key","value","element","Array","isArray","elements","isString","tempDiv","innerHTML","push","toArray","children","firstChild","className","classList","add","hasClass","replace","contains","split","indexOf","cssObj","property","val","min","max","iterable","slice","call","arr","constructor","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","pos","range","center","callback","i","counterArray","indexed","size","offset","originalStyle","setAttribute","removeAttribute","prototype","flickingName","args","result","_a","bbox","y","offsetWidth","offsetHeight","clientRect","getBoundingClientRect","left","top","index","viewport","prevSibling","nextSibling","clonedPanels","state","relativeAnchorPosition","isClone","isVirtual","cloneIndex","cachedBbox","setElement","givenBbox","options","getBbox","prevSize","parseArithmeticExpression","panel","cloneState","panelCount","panelManager","scrollAreaSize","getScrollAreaSize","relativeIndex","floor","getPosition","progress","getCurrentProgress","outsetRange","getSize","getRelativeHangerPosition","getRelativeAnchorPosition","relativePanelPosition","getCameraPosition","outsetProgress","getProgress","panelSize","rightRelativePanelPosition","visibleSize","visibleRatio","currentPanel","hangerPosition","getHangerPosition","anchorPosition","getAnchorPosition","currentPosition","eventType","findEstimatedPosition","updateFunction","shouldResize","identicalPanels","getIdenticalPanels","eachPanel","unCacheBbox","addVisiblePanel","currentIndex","prevPanelIndex","prevPanelPosition","prevPanelSize","hasEmptyPanelBetween","notYetMinPanel","newPosition","prevPanel","clone","getCloneIndex","setPosition","getLastIndex","nextPanelIndex","nextPanelPosition","notYetMaxPanel","nextPanel","parsedElements","parseElement","firstPanel","targetIndex","insert","remove","option","preserveUI","restoreStyle","wasVisible","Boolean","parentNode","cameraElement","getCameraElement","appendChild","classes","classes_1","original","getClonedPanels","elementStyle","currentElementStyle","styleToApply","cloneElement","cloneNode","clonedPanel","Panel","clonedState","removeClonedPanelsAfter","start","removingPanels","splice","removeElement","currentElement","getAttribute","addClass","applyCSS","panels","clones","cloneCount","reduce","allClones","newPanels","newClones","findIndex","filter","lastPanel","firstRemovedPanel","possibleLastPanel","shouldRender","isCircular","findFirstPanelFrom","siblingElement","insertNewPanels","pushedIndex","panelsAfterIndex","emptyPanelCount","removedPanels","newLastIndex","concat","reverse","setIndex","updateIndex","addNewClones","panelCount_1","cloneSet","replacedPanels","wasNonEmptyCount","deleteCount","deletedPanels","reversedPanels","nonEmptyIndexFromLast","allPanels","allPanelsCount","newClones_1","insertTarget_1","allPanels_1","panelElement","originalPanels","getCloneCount","lastPanelClones","nextSiblingClones","cloneNextSibling","lastPanelSibling","cloneSiblingElement","nextElementSibling","map","_this","this_1","insertClones","counter","insertingIndex","fragment_1","createDocumentFragment","prevState","delta","direction","targetPanel","lastPosition","nextState","e","context","tslib_1","flicking","triggerEvent","transitTo","moveCamera","onSuccess","onStopped","onChange","State","inputEvent","offsetX","offsetY","flick","setTo","releaseEvent","srcEvent","clickedElement","touchEvent","touch","changedTouches","elementFromPoint","clientX","clientY","clickedPanel","findPanelOf","cameraPosition","clickedPanelPosition","stopCamera","absDelta","abs","velocity","velocityX","velocityY","inputDelta","deltaX","deltaY","isNextDirection","swipeDistance","swipeAngle","atan","PI","belowAngleThreshold","overThreshold","moveTypeContext","axesEvent","interruptDestInfo","findPanelWhenInterrupted","destPos","nearestPanel","getNearestPanel","stop","destInfo","findTargetPanel","findRestorePanel","scrollArea","getScrollArea","loopCount","originalTargetPosition","newCloneIndex","circulate","newTargetPosition","newTargetPanel","setCurrentPanel","isTrusted","updateAdaptiveSize","updateAxesPosition","IdleState","nextStateType","currentState","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","onEnter","onHold","onRelease","onAnimationEnd","onFinish","ctx","findRestorePanelInCircularMode","halfGap","minimumDistanceToChange","originalPanel","getOriginalPanel","firstClonedPanel","lapped","_super","snapCount","eventDelta","calcBrinkOfChange","nearestIsCurrent","shouldMoveWhenBounceIs0","canSetBoundMode","shouldMoveToAdjacent","isOutOfBound","findSnappedPanel","findAdjacentPanel","estimatedHangerPos","panelToMove","cycleIndex","passedPanelCount","panelPosition","panelNextPosition","panelPrevPosition","siblingPanel","panelIndex","siblingIndex","originalPosition","defaultDuration","getCurrentIndex","get","basePanel","basePosition","adjacentPanel","targetRelativeAnchorPosition","estimatedPanelPosition","estimatedPosition","MoveType","estimatedPanel","findNearestPanelAt","stateMachine","getState","currentPanelPosition","lastHangerPosition","Snap","panelMaintainRatio","relativeHangerPosition","positionOffset","visibleIndex","NaN","translate","checkedIndexes","isAdaptiveCached","isViewportGiven","isCameraGiven","originalViewportStyle","originalCameraStyle","StateMachine","visiblePanels","panelBboxes","build","eventResult","axes","isBetween","findNearestPanel","originalNearestPosition","checkNeedPanel","modifiedNearestPosition","updateVisiblePanels","posOffset","moveVector","moveCoord","coord","round","join","viewportElement","updateSize","updateOriginalPanelPositions","updateScrollArea","updateClonePanels","updateCameraPosition","updatePlugins","minimumDistance","prevPosition","nextPosition","distance","minimumAnchorDistance","anchorDistance","nearest","shortestDistance","identicals","identical","getVisibleIndexOf","panInput","enable","disable","resizePanels","newCenterPanel","newPanelPosition","updateCheckedIndexes","indexes","wasEmpty","newCurrentIndex","getRange","undefined","shouldApplyAdaptive","viewportStyle","sizeToApply","panelBbox","maximumPanelSize","maximum","viewportBbox","updateBbox","viewportSize","plugins","plugin","update","wrapper","removePlugins","topmostElement_1","deletingElement","status","html","refreshPanels","createdPanels","orderedPanels","createdPanel","replacePanels","setCloneCount","getOutsetProgress","playing","holding","prevRange","nextRange","nearestAnchorPos","nearestIndex","nearestSize","hangerIsNextToNearestPanel","targetPosition","progressBetween","startIndex","off","on","axesHandlers","setLastIndex","handlers","newPlugins","init","currentPlugins","removedPlugins","changedRange","removed","fragment","prevVisiblePanels","equalSizeClasses_1","cached_1","overlappedClass","getOverlappedClass","clonePanels","updateClonedPanelPositions","chainAllPanels","visiblePanel","setElements","applyCSSValue","setMoveType","setAxesInstance","setDefaultPanel","moveToDefaultPanel","viewportCandidate","hasViewportElement","cameraCandidate","hasCameraElement","panelElements","child","minHeight","minWidth","PanelManager","FreeScroll","Axes","easing","interruptable","PanInput","scale","connect","indexRange","sumOriginalPanelSize","areaPrev","sizeSum","panelAtLeftBoundary","reversedPanels_1","areaNext","panelAtRightBoundary","panels_1","needCloneOnPrev","panel0OnFirstscreen","ceil","prevCloneCount","origPanel","removeClonesAfter","defaultPanel","defaultPosition","nextPanelPos","maintainingPanel","looped","panelsBeforeMaintainPanel","accumulatedSize","total","setPositionCSS","clonedPanels_1","cloneBasePos","clonedPanelPos","lastReplacePosition","_b","replacePosition","relAnchorPosOfCombined","anchorPos","parsedBounce","parsedVal","axis","isFreeScroll","is","maxLastIndex","triggerNeedPanel","checkingPanel","atLastPanel","nextIndex","currentNearestPosition","panelRight","cameraNext","emptyPanelExistsBetween","firstIndex","lastPanelAfterNeed","atLastPanelAfterNeed","cameraPrev","checkingIndex","atFirstPanel","prevIndex","panelLeft","firstPanelAfterNeed","atFirstPanelAfterNeed","params","alreadyTriggered","some","hasHandler","hasOn","fill","insertAfter","resetVisibleIndex","newVisibleIndex","calcNewVisiblePanelIndex","isNaN","newVisiblePanels","calcVisiblePanels","addedPanels","firstVisiblePanelPos","trigger","cameraPos","allPanelCount","checkLastPanel","getNextPanel","isOutOfViewport","lastPanelOfNextDir","lastPanelOfPrevDir","minPanelCloneIndex","maxPanelCloneOffset","minPanelCloneOffset","prevRefCount","newRefCount","newPanel","newIndex","added","default","defaultBbox_1","equalSizeClasses_2","tid","cid","random","category","action","label","innerWidth","innerHeight","screen","collectInfos","location","href","navigator","language","toLowerCase","charset","inputEncoding","characterSet","referrer","title","JSON","stringify","req","XMLHttpRequest","open","send","shouldResetElements","parent","origStyle","appendUncachedPanelElements","eventName","canceled","merge","previousPosition","inputOffset","cameraChange","currentDirection","querySelector","nodeName","nodeType","currentOptions","Viewport","listenInput","listenResize","sendEvent","focus","possiblePositions","nearestPosition","current","includeClone","outerHTML","restore","addPlugins","removeEventListener","diffResult","maintained","values","before","after","prevPanelCount","prevList","list","visibles","changedIndex","renderingPanels","setVisiblePanels","diffInfo","changed","prevClonedPanels","prevOriginalPanels","beforeIdx","afterIdx","addIndex","groupIndex","prevCloneGroup","newCloneGroup","getCheckedIndexes","has","isPanelChangedAtBeforeSync","beforeDiffInfo","prevOriginalPanelCount_1","originalPanelCount_1","originalAdded","originalRemoved","originalMaintained","originalChanged","beforeSync","addedIndex","addedElement","beforePanel","eventContext","fire","connectAxesHandler","addEventListener","Flicking","Component"],"mappings":"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"}